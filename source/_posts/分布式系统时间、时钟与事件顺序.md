---
title: 分布式系统时间、时钟与事件顺序
date: 2018-11-05 20:59:41
categories:
- 分布式系统
- 逻辑时钟
tags:
- 分布式系统
- 时钟同步
- 逻辑时钟
- 物理时钟
- lamport clock
---

如何确定分布式系统各节点（进程）中事件发生的先后顺序至关重要。时钟不一致会导致系统发生不可预料的逻辑错误。然而绝大部分情况下，不能依赖于物理时钟，因为不同的系统的物理时钟总会存在不同程度的时钟漂移（多处理器机器中也类似），即便各节点定期通过网络从时钟源进行时钟同步，也无法确保各节点时钟完全一致。因此，早在1978年，Leslie Lamport 便提出了逻辑时钟的概念，并描述了如何利用逻辑时钟来定义分布式系统中事件的发生顺序。它大致基于事件发生的因果关系，并保证能够正确排列系统中具有因果关系的事件，这使得分布式系统在逻辑上不会将具有因果关系事件的发生顺序倒置。

<!--More-->

## 时钟同步

事实上，计算机的时钟会以不同速率来计时，普通的石英钟漂移(`skew drift`)1秒所需的时间大概为11-12天。因此如果使用物理时钟`physical clock`所定义的时间戳来确定系统中事件发生顺序，需要对物理时钟进行定期同步(`clock synchronization`)。在理想网络环境下，通过网络将带有时间戳的消息在时钟源（`UTC`,`Coordinated Universal Time `）与本地机器之间传输，能够保证本地时间与时钟源基本一致。但事实上，网络是异步的且有延时，因此无法保证不同节点之间的时钟完全同步。尽管如此，我们可以通过算法来尽可能提高时钟同步精度。著名的时钟同步算法如[`Cristian's Time Sync`](https://en.wikipedia.org/wiki/Cristian%27s_algorithm)和[`Berkeley algorithm`](https://en.wikipedia.org/wiki/Berkeley_algorithm)。

## Lamport Clock

相比于通过同步物理时钟的方式来协调各节点的时间，在分布式系统中，更为普遍且合理的方式是使用逻辑时钟(`logical clock`)。Lamport 提出的逻辑时钟舍弃了物理时钟固有的无限粒度的性质，它基于事件发生的因果关系(`causality`)。换言之，所有的事件通过`happened before`来关联，以`->`表示。对于事件`a`与`b`，`a->b`表示`a happened before b`，它是一种偏序关系(`partial order`)，分布式系统中所阐述的事件发生的先后顺序一般为偏序。Lamport 在分布式系统内定义了三种类型的事件，包括进程（节点）内事件、进程发送消息事件以及进程接收消息事件。`a happened before b`由以下三个条件中任一一个触发：

1. 若`a`与`b`表示同一进程内的事件，并且`a`发生在`b`之前，则有`a->b`。
2. 若`a`代表某一进程发送消息的事件，`b`代表另一进程接收此消息的事件，则有`a->b`。
3. `happened before`关系满足传递性。

如下图（水平方向表示物理时钟增加方向，垂直方向表示不同进程），由规则(1): `a->b`及`c->d`; 由规则(2): `b->c`和`d->f`; 由规则(3): `b->f`。但并非所有的事件都能通过`->`关联，比如`a`与`e`为不同进程不同消息链上的事件，则只能被定义为并发的两个事件，记作`a||e`。事实上，事件`a`与`e`没有因果关系，因此，从系统正确性的角度而言，它们之间真正的发生顺序不会影响到系统的正确性，所以我们不需要关注它们发生的先后顺序。

![lamport clock](http://phpzmnp6v.bkt.clouddn.com/static/eb415390449c57ea8f6c9e33c82a7e9.png)

如果将系统中所有发生的事件`e`标记一个单调递增的时间戳(`L(e)`)（与物理时钟没有关系），也称为`lamport timestamp/clock`，每一个进程都会维护自己的逻辑时钟，时间戳标记原理如下：

1. 每个事件对应一个初始的时间戳，初始值为0。
2. 如果发生的事件为进程内事件，则时间戳加1。
3. 如果事件为发送事件，则将时间戳加1，并在消息中带上该时间戳。
4. 如果事件为接收事件，则其时间戳为max(进程时间戳，消息中附带的时间戳)+1。

如下图，`p1`、`p2`以及`p3`都有自己的初始的逻辑时钟0；进程的全局（当前）逻辑时钟即为当某一事件发生之后的逻辑时钟值，如事件`a`与`b`的逻辑时钟值分别为`0+1=1`和`1+1=2`。而发`p1`发送消息`m1`给`p2`后，`c`的逻辑时钟值为`max(0, 2)+1=3`。

![lamport clock-2](http://phpzmnp6v.bkt.clouddn.com/static/lamport%20clock-2.png)

在`lamport clock`表示法中，对于事件`e1`与`e2`，`e1->e2`能推断出`L(e1)<L(e2)`，但反之不成立，即`L(e1)<L(e2)`不能推断出`e1->e2`，如在图(2)中，`L(b)>L(e)`，但实际上有`b||e`。另外，并发事件也是类似的，即若`L(e1)=L(e2)`可以推断出`e1||e2`，但反之不成立。对于`lamport clock`，并发事件没有可比性，正如上文所述，并发事件发生的先后顺序并不影响系统逻辑正确性。

在`lamport clock`表示法中，无法确定没有因果关系的事件的先后顺序，而大多数分布式系统确实需要对所有的事件进行全局排序(`total order`)，而不仅仅得到影响系统正确性的事件之间的偏序关系(`partial order`)。换言之，为了得到一个全局的事件发生顺序，必须对并发事件进行先后发生顺序的判定。因为并发事件真正发生的先后顺序不影响系统的准确性，因此可以为它们统一制定一个任意顺序规则（事实上，`lamport clock`就是这么考虑的）。比如同其它因果关系事件类似，以逻辑时钟(`L(e)`)的大小来判定，逻辑时钟小的发生在前，反之则发生在后。而对于逻辑时钟相同的并发事件，在`lamport clock`算法当中，给出的解释是根据进程号(`PID`)的大小来确定，进程编号更小的发生在前。其实，Lamport 在论文中提到过，也可以采用其它方式来确定并发事件的先后顺序，这似乎没有理论依据，但是正如前面所述，通过引入`lamport clock`，可以在逻辑上保证系统的正确性，我们不关心那些不影响系统正确运行的事件之间的顺序。但以进程编号作为依据，似乎影响到了系统的公平性，比如当两个进程竞争同一物理资源，物理时间上先发出请求的进程不一定能先锁定资源，但这并不会造成系统逻辑错误。在`lamport clock`原论文中，给出的实例便是分布式系统资源竞争或者互斥占用，大家可以参考原论文。

## Vector Clock

前文提到`lamport clock`存在一个缺点，即对于事件`e1`与`e2`，`L(e1)<L(e2)`并不能推导出`e1 happened before e2`，换言之，其只能确定单方的因果关系关联。`vector clock`是在`lamport clock`上演进的一种逻辑时钟表示法，它完善了`lamport clock`这一缺陷，能提供完整的因果关系关联。在`vector clock`表示法中，每个进程维护的不仅仅是本进程的时间戳，而是通过一个向量(`vector`)来记录所有进程的`lamport clock`以此作为进程的逻辑时钟，即进程事件的逻辑时钟被表示为：`v(e)[c1, c2..., cn]`，其中`ci`为进程`i`中先于事件`e`发生的事件。`vector clock`的逻辑时钟标记原理同`lamport clock`原理类似。

如下图，在进程`p1`中，事件`a`的逻辑时钟为`(1,0,0)`，发送消息`m`的事件`b`的逻辑时钟为`(2,0,0)`。在进程`p2`中，其接收消息`m1`的事件`c`的逻辑时钟为`max((0,0,0),(2,0,0))+1=(2,1,0)`。此时，对于事件`e1`与`e2`，由`e1 happened before e2`推断出`v(e1)<v(e2)`，反之亦然。在`vector clock`表示法中，事件`c`与`e`是并行事件，记作`c<->e`，因为我们不能推导出`v(c)<=v(e)`，也不能推导出`V(e)<=v(c)`。注意，此时逻辑时钟值的比较(`<|>|<=|>=`)是对向量的分量逐一比较。

![vector clock](http://phpzmnp6v.bkt.clouddn.com/static/vector%20clock-1.png)



参考资料：（插图出自 CMU Lecture）
[1] https://en.wikipedia.org/wiki/Cristian%27s_algorithm
[2] https://en.wikipedia.org/wiki/Berkeley_algorithm
[3] Lamport L. Time, clocks, and the ordering of events in a distributed system[J]. Communications of the ACM, 1978, 21(7): 558-565.
[4].[CMU 15-440 Distributed System Lecutre 9](https://www.cs.cmu.edu/~dga/15-440/S14/index.html)