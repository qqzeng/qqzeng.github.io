---
title: nsq 简介和特性理解
date: 2019-05-11 21:51:04
categories:
- 消息队列
tags:
- 消息队列
- 分布式系统
---

前段时间写的分布式系统相关`lab`，都是使用`go`语言，还挺有趣的这门语言，但至今也没系统了解过它。不得不说，纯粹了解或学习语言特性，长时间下来会有点枯燥。个人更习惯阅读开源项目，以更深入了解其在实际工程项目的最佳实践（但似乎不能对语言特性本质有太多的了解，尴尬）。很自然地选择了一个对于初学者比较经典的`starter project`，一个**分布式实时消息队列**——`nsq`。大家比较熟悉的消息中间件可能是像`RabbitMQ`、`ActiveMQ`、`RocketMQ`以及`kafaka`之类的。我个人对这些消息中间件并没有实践经验，但感觉`nsq`更轻量级（代码量也少），而且正如官方对其的定义，其最主要优势在于**分布式**和**实时**。具体对比，可以参考`golang 2017`开发者大会上的一张图。`nsq`遵循的是一个去中心化的的拓扑结构，其具备**高可用性**（无单点故障`SPOF`）、**可扩展**（支持水平扩展节点）、**低延迟**（采用`push`的方式）、**可靠消息传递**（消息可被持久化和失败重入队列）、**组合式负载均衡**（消息推送为随机负载均衡）以及**消费者自动发现和连接生产者**（通过服务发现与注册系统实现）等特性。笔者打算后面通过一系列博文，深入到`nsq`源码，简析其各模块（组件）的设计实现。

<!--More-->

按照惯例，先声明下阅读本文章的前提。本文不会详细介绍[nsq](https://nsq.io/overview/quick_start.html)基本特性，也不会过多阐述消息队列的基本功能和使用场景，也不会涉及到`nsq`如何使用及其最佳实践。换言之，阅读本文前最好对这些有初步了解，以在整体上有所把握和体会。关于`nsq`可参考官方文档的文献[1]、[2]、[3]和[4]，或者其它中文文章[4]。本文先简要介绍`nsq`各组件及基本工作流程，然后详细阐述`nsq`几个值得注意的特性。若有理解错误的地方，欢迎指正！

![mq-comparison](https://github.com/qqzeng/qqzeng.github.io/blob/hexo/static/mq-comparison.png?raw=true)

## nsq 基本介绍

在本文最前面，简要阐述了`nsq`的几个重要特性（官方文档列举的更全），我们会重点阐述这些特性。关于它们中的一些，我们深入到代码以了解其是如何实现的。而其它的典型的包括：易于部署，因为它没有太多依赖配置（通过命令行就可以配置）；支持安全传输层协议 (`TLS`)；还提供了多种语言的客户端功能库；最后附带一个简易的集群管理界面`nsqadmin`。`nsq`主要包括两个组件`nsqd`和`nsqlookupd`，和一个管理界面`nsqdadmin`：

- `nsqd`是一个负责接收、排队、转发消息到客户端的守护进程；
- `nsqlookupd`是一个管理集群(`nsqd`)拓扑信息并提供最终一致性的服务注册与发现的守护进程；
- `nsqadmin`是一个管理界面，提供实时的集群中`topic`、`channel`和`message`的统计信息，还提供与这些实体相关的各种管理接口。

在这里简单阐述整个系统的典型流程。除了上述几个组件外，另外两个核心的概念为主题(`topic`)和通道`channel`，当然消息(`message`)也是重要的。它们的简单阐述如下：

- `message`即代表的是数据，它被生产者创建并发送到指定的`topic`，而消费者可以从指定的`topic`和`channel`接收并消费消息。且每个被`nsqd`接收到的消息至少会被发送一次给消费者，因为消息消费超时会触发重入队过程，且消息附带有一个投递次数属性，以使得客户端对投递次数过大的消息灵活处理。
- `topic`代表生产者投递消息的一个逻辑键值，它可以将消息进行分类。一个`nsqd`上可包含多个`topic`，且它们可以不必在生产者投递消息前就创建，换言之，`topic`可在其第一次接收到生产者投递的消息时创建。
- `channel`代表消费者订阅某个`nsqd`上的`topic`的消息。你可以仍旧将它视作一个消息队列，只不过它与消费者相关。每当生产者将消息发布到一个`topic`上，消息会被**拷贝**（深拷贝，即构建一个消息副本）到与`topic`关联的所有的`channel`。而且，多个消费者可以订阅同一个`channel`，`channel`会将其接收到的消息**随机**（即随机负载均衡）发送到与其关联的一个客户端。同`topic`类似，`channel`也可不用提前创建，消费者在第一次订阅消息（在指定`topic`的某个`channel`）的时候会创建此`channel`（若其不存在）。最后，`channel`从`topic`接收的消息首先会在内存中排队，当达到内存队列长度上限，就被写到持久化存储。

`nsqd`在启动时通常会建与各`nsqlookupd`的连接。`nsqlookupd`为其提供目录服务，即`nsqd`可将`topic`、`channel`及`nsqd`(生产者)的信息注册到`nsqlookupd`，并且可通过与`nsqlookupd`之间的`TCP`连接动态更新自己的状态信息（`topic`及`channel`信息等）。而消费者可通过`http`请求连接到`nsqlookupd`，以查找其感兴趣的`nsqd`的地址。正是通过这种设计使得消费者与生产者分离，从而降低系统复杂性。在获取到生产者(`nsqd`)的地址后（准确而言，还包括`topic`及`channel`） ，消费者（`nsq`客户端）可直接连接到`nsqd`，以等待对方发送消息（不是主动去拉到消息，而是等被对方推送消息）。另外，为了提供更好的吞吐量，`nsq`允许消费者显式地向`nsqd`声明其能够处理的消息数量，这可以提高消息的吞吐量（避免消费者积压消息的情况）。针对每一个消息，当消费者消费完成后，其需要回复`nsqd`一个`FIN`消息，否则消息会被重入队，然后再一次被发送给消费者。最后，有一点需要注意，客户端（消费者）一次性只能订阅一个`channel`。官方文档提供的消息流动图如下：

![mq-comparison](https://github.com/qqzeng/qqzeng.github.io/blob/hexo/static/nsqd-message-pub-sub-process.gif?raw=true)

## 关键特性

个人在阅读官方文档之后，对于其描述的一些特性比较模糊，甚至有一些误解，在后面的进一步了解过程（甚至有些东西未深入到源码是不太能理解的），因此个人总结下如下几点是需要特别理解和注意的：

- `nsq`官方所声称的**去中心化分布式**特征，指的是，因为各节点(`nsqd`甚至也包括`nsqlookupd`)之间不会产生状态（数据）共享或依赖，因此可以直接通过添加节点来提升系统处理能力（即系统可通过水平扩展来来线性提升处理能力），且单个节点宕机不会影响其它节点的功能。因此，正是因为节点之间没有状态共享，没有数据冗余或副本的概念，使得它也不需要使用复杂的一致性算法来保证数据的一致；
- 虽然官方声称其是具体**可靠消息传递**，但是需要注意的是，其的确也存在消息丢失的情形，因为虽然它通过提供消息持久化来缓解这一问题，但并没有根本解决这一问题，一旦宕机，内存中的消息会丢失，当然你可以将内存队列长度`mem_queue_size`参数设置地更小一些以缓解此问题。甚至，你可以节点作冗余操作，以保证数据丢失的可能性在实际生产中几乎不可能发生（注意不是不可能发生），但对于那些需要高可靠性的消息发布的应用场景，`nsq`是无法保证的。
- 还有，官方文档提到一点，`nsq`并没有`kafaka`那么强大，它不能保证**消息的严格顺序**，换言之，生产者创建的消息可以随时（不确定性）地以任何顺序进入到`nsqd`的消息队列。典型地，官方推荐将消息生产者与`nsqd`实例协同部署，即部署在同一台机器上，这样即使发生网络分区，也不会影响生产者消息的投递，明显在此种情况下消息投递的效率理论上会被其它情况下的消息投递效率。但官方提供了一种解决方案，即将消息打上时间戳。尽管如此，它仍然不适合需要保证严格消息顺序的情况下。
- `nsq`保证的消息**至少一次**会被发送给生产者。换言之，消息可能被多次发送给消费者。因此，消费者应该能够识别消息重复(`message de-duplicate`)，或者保证消息所涉及的操作幂等性(`idempotent`)。更具体地，造成消息被多次发送的原因包括，客户端连接断开或消息超时时间内未返回响应，这些都会导致消息的重入队操作(`requeue`)。
- 关于`nsqlookupd`，其也是可**水平扩展**的，但各节点实例之间也是没有任何联系的，结合业务逻辑来阐述，即每个`nsqdlookupd`实例可分别接收部分或全部的`nsqd`实例的服务注册请求，这只需要客户端在连接到`nsqlookupd`获取所有的生产者(及`topic`和`channel`)信息后，对获取的数据进行一个`union`操作即可，便可得到整个系统中生产者的拓扑信息（这即是官方文档中所描述的将发现服务设计成`eventually consistent`）。
- 最后，不得不说的一点是，正是因为上面所描述的各种不足，造就了`nsq`的**精简设计**。简单实在是太重要了！因为简单意味着容易进行故障或bug查找，同时，容易部署和使用方便。不得不说，当满足了应用的基本功能之后，简单往往是最重要的一个因素。

小结一下，本文先简要介绍了`nsq`的各个组件及基本工作流程，然后重点阐述了几个值得关注的特性，这些特性（包括未讨论的）以及`nsq`的各个组件，会在后面的博文中阐述。为了更好地理解`nsq`，个人建议，先仔细阅读官方文档，并简单实践，若有兴趣，深入源码查看会收获更多。



参考文献

[1]. [nsq Features & Guarantees](https://nsq.io/overview/features_and_guarantees.html)
[2]. [nsq Design](https://nsq.io/overview/design.html)
[3]. [nsq Quick Start](https://nsq.io/overview/quick_start.html) 
[4]. [nsq - NYC Golang Meetup](https://speakerdeck.com/snakes/nsq-nyc-golang-meetup)
[5]. [消息中间件NSQ深入与实践](https://juejin.im/entry/59ddae8151882578bb480d0e)