---
title: Live Sequence Protocol 实现
date: 2018-10-25 18:55:51
categories:
- 分布式系统
- 传输协议
tags:
- 分布式系统
- 网络编程
- 传输协议
- 可靠服务
- 流量控制
---
分布式环境中，网络不稳定导致消息（数据包）的传输存在乱序、重复和丢失的情况，同时，节点宕机也不可避免。如何优雅地处理这些问题，是构建一个健壮的分布式系统的关键。网络的复杂性使得数据包传输协议至关重要。低级别的IP协议提供不可靠的数据报服务，即消息可能延时、重复或丢失，另外，它也限制了在网络节点中传输的消息的最大字节数，因此很少直接利用IP协议来构建分布式应用。在传输层，UDP也不提供可靠的数据报服务，但它可以通过端口定向传输报文。而TCP则会保证消息传输的可靠性、有序性，并允许任意字节大小的消息传递，还提供额外的功能，如流量控制、拥塞控制。

<!-- more -->

我们的目的是实现一个基于UDP、具备TCP几个关键特性的消息传输协议 (`Live Sequence Protocol`），同时它还具备如下功能：
- 不同于UDP或TCP，它支持 `client-server`通信模型 。
- `server`会维护若干个`client`的连接。
- `server`与`client`的通信是通过向对方发送消息来实现，消息大小限制与UDP相同。
- 消息传输是可靠的：消息一旦发送，就会被顺序接收，且每个消息只会被接收一次。
- `server`与`client`可以检测连接的状态。

协议具体的工作原理、关键特性、运行流程及开放使用的接口可以参考[`p1.pdf`](https://github.com/qqzeng/15-440/blob/master/p1/p1.pdf)。下面我会讨论协议实现过程中的几个关键点，以及个人在实现过程中遇到的棘手的问题。

## 系统逻辑框架构建

清晰且优雅地构建整个系统的逻辑框架至关重要，代码框架设计关系到后期功能模块调试与扩展，不合理的系统逻辑框架设计会使得后期的扩展寸步难行，也会导致代码的可调试性、可读性变差。因此，在编写出你的第一个可用的版本之前，尽可能合理地安排系统框架，这需要理解并梳理系统的主干及各分支（异常）运行流程，为了更简单、高效且合理地实现模块功能，必须尽可能熟悉(`go`)语言的特性(`channel`、`gorountine`及`interface`)。 

协议实现文档清晰地描述了协议的完整工作流程，按照此流程，其核心是`epoch event`触发后，协议的应对逻辑，可以实现出一个可运行的版本。合理安排程序框架关键在于处理好以下三个方面的问题：
- 哪些功能逻辑应该被顺序执行，如何保证同步顺序执行。
  比如，当创建`client`后，只有当其与`server`建立连接`connection`（抽象连接，并非消息传输所使用的连接）后才能返回，同时启动后台服务。注意`client`创建UDP连接到`server`可能会尝试多次，因为`server`可能存在慢启动问题，而且`Connect`消息也可能丢失。
- 系统需要哪些后台服务(`background goroutine`)， 后台服务如何可靠地同主线程协调交互。
  比如，对于`client`而言，至少需要三个`goroutine`来处理消息。
  - `read goroutine`持续从连接中读取消息，直到连接关闭。
  - `write goroutine`，因为写操作的调用是非阻塞的，但由于滑动窗口大小限制，并非所有消息都能立刻cache到滑动窗口并立即发送出去，因此，可以将用户`wirte`的消息放入到消息的`write channel`中，然后由专门的后台服务从`channel`中取消息，并在恰当的时候发送消息。
  - `epoch event trigger goroutine`，即处理与`epoch`相关的逻辑，超时如何处理？接收到`Ack`消息或`Data`消息如何处理？达到`max epoch`时如何处理？
- 确保开放接口的实现符合协议规范中预定义的准则要求。
  比如，`server`的`Read`接口的调用会阻塞直到其从任一`client`收到消息，然后返回消息的`payload`及对应的`connection ID`。如果连接丢失，关闭或者`Server`主动关闭终止，都应该返回错误提示。这个方法不应该被简单地设计成从连接中持续读取数据，因为`Server`可能连接多个`client`，针对每一个`client` 连接的读取，必须启用单独的`goroutine`。所以，一种简单的设计是`server`并发地从各连接读取数据，若通过了校验（如保证用户调用`Read`所返回的数据正是用户所期望的），则将数据放入到`channel`，让`Read`持续从`channel`中取数据，注意数据一旦添加到`channel`中，则会以放入的顺序被`Read`取出，并返回给用户。

## 理解UDP通信本质

大家可能对`TCP`原理及编程更为熟悉，`UDP`相对简单，但因为`lsp(Live Sequence Protocol)`基于`UDP`，并在更高的协议抽象层面具备TCP的特性，所以，不要混淆了二者的通信原理。`UDP`是无连接的！它会完全按照程序员的意愿发送消息，它不考虑对方主机是否存在或正常工作，也不会主动重发消息，因此，也就无法保证消息的可靠接收与发送。

所以，`server`不需要也不能维护其与`client`的连接！但应当在`sever`端创建并维护与其通信的`client`关联的信息实体（需包含哪些数据？），那何时创建？答案是当`server`读取到数据时，因为此时可以获取读取所返回的`client`地址，`server`可以通过cache已经连接的信息来判断此次读取对应的连接是否是新的连接。若不是，则直接进入消息读取处理逻辑，否则需要先初始化`server`维护的`client`相关联的信息实体。

最后，注意`server`与`client`使用的是不同的`UDP`读写通信接口。（`client`直接持有与`server`通信的连接，而`server`是通过指定地址（`IP+port`）发送与接收消息）。

## 如何实现滑动窗口

滑动窗口`sliding window`是协议实现流量控制的关键，是整个协议的功能核心，并且其与TCP的滑动窗口机制类似。关于滑动窗口，在理解它的工作原理后，重点考虑以下三个方面：
- 设计滑动窗口的数据结构。
  - 消息应该被有序添加到滑动窗口。
  - 发送消息窗口需要标识每一条消息是否已经被ack。
- 发送消息所关联的滑动窗口`latestSentDataMsg`。
  以`client`作为示例，维持其发送消息的窗口，以便对未按时返回`Ack`的消息进行重发（已发送的`data`消息可能会丢失，或者接收主机响应的`Ack`消息丢失）。
  - 因为窗口内的消息所返回的`Ack`是无序的（消息异步发送，网络传输也不能保证消息按序到达），所以，需要维护一个指针，表示当前返回的`Ack`消息的最小的序号`receivedAckSeqNum`，以作为窗口向前推进的依据。
  - 当`client`发送`data`消息时，需同时将其cache到`latestSentDataMsg`。而当其接收到`Ack`消息时，需要执行更新此指针`receivedAckSeqNum`的逻辑。
  而`server`则需要对其所维护的每一个连接构建对应的发送消息窗口，但处理逻辑类似。
- 接收消息所关联的滑动窗口`latestReceivedDataMsg`。
  同样以`client`作为示例，维持其接收消息的窗口，以便在计时器超时后，对最近收到的若干个`data`消息，重发`Ack`消息。
  - 同样，接收消息窗口也是无序的，因此，为了保证返回给用户的消息有序，需要维护一个指针，表示下一个期望接收到的`data`消息序号`nextReceiveDataSeqNum`（或者是当前已经接收到的最大的`data`消息的消息序号），它是依次递增的。对于接收到的任何`data`消息，若其`SeqNum`在此指针之后，都应该直接添加（暂时缓存）到`latestReceivedDataMsg`中，而不应该作为`Read`调用的返回结果。
  - 当`client`收到`server`的`data`消息时，也需要将其cache到`latestReceivedDataMsg`，并判断是否需要更新`nextReceiveDataSeqNum`，若需要更新，则应当将更新过程中所涉及到的cache在接收消息窗口中的`data`消息按序添加到供`Read`接口所读取的`channel`。
  `server`同样是一个连接对应一个接收消息窗口。

## 如何实现流量控制

流量控制表示若当前主机有过多的消息未被ack（网络拥塞），因此发送主机需要对用户调用`Write`接口的`data`消息进行阻塞以延缓发送。其实现关键是滑动窗口机制。具体实现原理为：
1. 当用户调用`Write`接口以发送消息时，将消息添加到消息发送队列`channel`，然后返回，不能阻塞。
2. 后台服务`write goroutine`从消息发送队列中不断的取消息，但在消息正式发送前，需要检测消息发送滑动窗口是否空闲`idle`，并且包含多少空闲的`slot`。
3. 空闲的`slot`数目可以根据以下表达式计算：
   `idleSlotNum := cli.params.WindowSize-(lastMsg.SeqNum-cli.receivedAckSeqNum)`，其中，`lastMsg`为消息发送窗口中最后一个消息，即`SeqNum`最大的消息。
4. 如果`idleSlotNum`大于0，则可以发送对应数目的消息，并将已经发送的消息记录到消息发送窗口，同时递增`nextSendDataSeqNum`指针。否则，`write goroutine`应该被阻塞住。那如何解除阻塞？每当`client`在接收到`Ack`消息时都要去尝试解除阻塞。

如图所示，当滑动窗口处于(a)的情况下，当用户调用`Write`以发送消息时，消息会被阻塞在`write channel`中，因为此时`receivedAckSeqNum`为9，消息发送窗口的`idle`的`slot`数目为：5-(14-9)=0。而当`client`接收若干`Ack`消息后，滑动窗口转移到(b)状态时，注意到`receivedAckSeqNum`从9逐一递增到11，消息发送窗口`idleSlotNum`为：5-(14-11)=2，因此窗口前移，并可以从`write channel`中顺序取出两个消息，进行发送。

![traffic control](https://raw.githubusercontent.com/qqzeng/15-440/master/p1/traffic%20control.png)

## 如何检测消息重复

消息重复主要包括`data`和`Ack`消息的重复接收。以`client`作为示例。
- `data`消息的重复接收。
  - 当`client`读取到`data`消息后，需要判断消息是否已经接收过。若消息重复，则直接返回`Ack`消息，否则应该先将消息cache到`latestReceivedDataMsg`。
  - 可以通过消息的`SeqNum`来去重。这涉及两种情况：其一，消息已经被`Ack`，并且已经从`latestReceivedDataMsg`中移除，我们称之为消息被丢弃(`discarded`)。其二，消息被`Ack`，但仍然cache在`latestReceivedDataMsg`中。
- `Ack`消息的重复接收。`Ack`消息的去重逻辑同`data`消息类似。

## 如何保证消息顺序

发送主机异步发送消息，且消息在网络中传输也有不同程度的延迟，因此接收主机接收的消息序列的顺序很可能与发送主机发送的消息顺序不同。如何保证消息顺序？准确而言，如何以发送主机发送消息的顺序来返回给用户。

针对具备滑动窗口机制的消息传输，可以保证滑动窗口前所接收的消息，即已经被`discarded`的消息肯定是有序返回给用户的。而滑动窗口内的消息，因为无法规避从网络中读取乱序消息的问题，但在读取到消息后可以控制以何种顺序将消息返回给用户。简单而言，将收到的`data`消息先cache在`latestReceivedDataMsg`中，然后通过指针`nextReceiveDataSeqNum`来判断是否应该将窗口中cache的消息返回给用户。

## 如何优雅地关闭连接

保证连接优雅地关闭是一个非常棘手的问题。其中，相比于`client`端的连接关闭，`server`的关闭又更为复杂。协议规范清晰地描述了`client`及`server`在关闭连接时需要注意的问题。其核心是：
- 当存在`pending`消息时，需要将其处理完成（即需保证接收到`Ack`消息）。
- 同时，一旦`data`消息被加入到`write channel`，它必须保证最后能够被发送出去。
`client`的关闭相对简单，具体处理逻辑为：当用户调用`Close`接口时，需要判断是否存在`pending`消息，如何检测？两个条件：
- 保证消息发送窗口的最后一个消息的`SeqNum`恰好为其持有的`receivedAckSeqNum`的值。
- 保证`write channel`中没有任何未被处理的消息。
因此如果此时存在`pending`消息，`Close`会被阻塞。那如何解除阻塞？每当`client`在接收到`Ack`消息时都要去尝试解除阻塞。此外，值得注意的是，在阻塞的过程中，如果触发了`max epoch event`，则`client`应该立刻返回，因为这表明连接已经`discarded`，此时要么所有`pending`消息已被处理，要么`server`主动关闭了连接。
`server`的`CloseConn`接口可以看作是`client`的`Close`接口的非阻塞版本。而`Close`接口需要协调所有的`connection`的关闭。同样，`server`的某个连接也可能到达`max epoch`，此时其对应的连接应该被关闭。当所有连接都关闭时，`Close`才能返回。
在连接关闭时，需要及时退出对应的`background goroutine`。

## 需注意的细节问题

往往一些编程方面的细节，包括逻辑漏洞或者被忽视的语法问题会造成很长时间的调试。而且，当通信过程中，数据交换复杂变得越发复杂时，很难从庞大的日志文件中找出错误的根源。个人在实现的过程中，遇到两个问题：
- `dead lock`。死锁很容易产生，一般有两个原因，其一，资源的相互持有，造成两个线程都无法向前推进。其二，没有正确嵌套使用锁，你需要清楚锁是否可重入。
- `buffered channel`。其导致的问题比较隐蔽，你首先要明确是使用带缓冲的`channel`或者不带缓冲的`channel`，如果是`buffered channel`，你需要确定它的大小，如果你不确定缓冲区数量是否足够，建议设置的稍大一些，但这个前提是，必须在合适的时机清空`buffered channel`，避免在复用`buffered channel`之后导致逻辑受到影响。

最后，需要提醒的是，分布式程序异步、并发，且网络复杂的特性导致其很难debug。所以，尽可能设计完善的日志流程，以帮助跟踪未符合期望的执行逻辑，并定位问题。

另外，cmu提供较为完善的测试程序，如果程序出现问题，可以对某一个或几个子测试用例进行单独测试，熟悉测试用例代码，了解测试用例流程是有必要的。

[参考代码在这里](https://github.com/qqzeng/15-440/tree/master/p1/src/github.com/cmu440/lsp)