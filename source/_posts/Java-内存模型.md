---
title: Java 内存模型
date: 2019-03-07 10:38:14
categories: Java并发编程
tags: 
- 并发编程
- 内存模型
---

并发编程中，需要处理两个关键问题：线程之间如何通信及线程之间如何同步。通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。`Java`语言是采用共享内存的方式来完成线程间通信的。为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。因此，Java内存模型（`Java Memory Model ,JMM`）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。

<!--More-->

并发编程中为了保证数据的安全，需要满足以下三个特性：
(a) **原子性**是指在一个操作中就是 cpu 不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。
(b) **可见性**是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
(c) **有序性**即程序执行的顺序按照代码的先后顺序执行。
且实际上，**缓存一致性问题**其实就是**可见性问题**。**处理器优化**可以导致**原子性问题**。**指令重排**会导致**有序性问题**。**为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。**

**Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。**
(a) `Java`内存模型规定所有的变量都存储在主内存中，每条线程还有自己的工作内存（本地内存），线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递需要自己的工作内存和主存之间进行数据同步进行。本地内存是 `JMM` 的一个抽象概念，并不真实存在。它涵盖缓存，写缓冲区，寄存器及其他硬件和编译器优化。
(b) `JMM`就作用于工作内存和主存之间数据同步过程。它规定了如何做数据同步以及什么时候做数据同步。因此，它决定一个线程对共享变量的写入何时对另一个线程可见。

**重排序**。从源代码到最终的指令序列，经历的重排序过程如下：源代码 -> **编译器优化重排序** -> **指令级并行重排序** -> **内存系统重排序** -> 最终执行的指令序列。
(a) 对于编译器，`JMM` 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，`JMM` 的处理器重排序规则会要求 `java` 编译器在生成指令序列时，插入特定类型的内存屏障指令，通过内存屏障指令来禁止特定类型的处理器重排序。
(b) 现代的多处理器大都支持`StoreLoad`屏障（其他 3 种类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中。

**`happens-before`**。通过`happens-before`概念来阐述操作之间的内存可见性。如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 `happens-before` 关系。与程序员密切相关的`happens-before`规则如下（另外的规则可以参考文献[2]或[3]）：
(1) **程序顺序规则**：一个线程中的每个操作，`happens-before` 于该线程中的任意后续操作。
(2) **监视器锁规则**：对一个监视器锁的解锁，`happens-before` 于随后对这个监视器锁的加锁。
(3) **`volatile` 变量规则**：对一个 `volatile` 域的写，`happens-before` 于任意后续对这个 `volatile` 域的读。
(4) **传递性**：如果 A `happens-before` B，且 B happens-before C，那么 A `happens-before` C。
注意，两个操作之间具有 `happens-before` 关系，并不意味着前一个操作必须要在后一个操作之前执行！`happens-before` 仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前。

**重排序**。如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在**数据依赖性**（读写、写写 和 写读三种情况）。
(a) 针对单个处理器中执行的指令序列和单个线程中执行的操作，编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。 
(b) 不管怎么重排序（为了提高并行度），（单线程）程序的执行结果不能被改变。即编译器，`runtime` 和处理器都必须遵守 `as-if-serial` 语义。为了遵守 `as-if-serial` 语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作可能被编译器和处理器重排序。
(c) 在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果（这也是 `as-if-serial` 语义允许对存在控制依赖的操作做重排序的原因）；但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。

**顺序一致性**。顺序一致性内存模型为程序员提供了极强的内存可见性保证：(1) 一个线程中的所有操作必须按照程序的顺序来执行。(2) （不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。
(a) `JMM` 对正确同步的多线程程序的内存一致性做了如下保证：如果程序是正确同步的，程序的执行将具有顺序一致性—— 即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同。换言之，未正确同步程序在 `JMM` 中不但整体的执行顺序是无序的，而且所有线程看到的操作执行顺序也可能不一致。
(b) 在顺序一致性模型中，所有操作完全按程序的顺序串行执行。而在 `JMM` 中，临界区内的代码可以重排序，以尽可能执行编译器和处理器优化（但 `JMM` 不允许临界区内的代码“逸出”到临界区之外，那样会破坏监视器的语义）。
(c) 对于未同步或未正确同步的多线程程序，`JMM` 只提供最小安全性：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值。`JMM`不保证未同步程序的执行结果与该程序在顺序一致性模型中的执行结果一致。

**`volatile`**。对一个 `volatile` 变量的单个读 / 写操作，与对一个普通变量的读 / 写操作使用同一个监视器锁来同步，它们之间的执行效果相同。简而言之，`volatile` 变量自身具有下列特性：(1) 可见性。对一个 `volatile` 变量的读，总是能看到（任意线程）对这个 `volatile` 变量最后的写入。(2) 原子性：对任意单个 `volatile` 变量的读 / 写具有原子性，但类似于 `volatile++` 这种复合操作不具有原子性。
(a) 从内存语义的角度来说，`volatile` 与监视器锁有相同的效果：`volatile` 写和监视器的释放有相同的内存语义；`volatile` 读与监视器的获取有相同的内存语义。
(b) `volatile` 写的内存语义如下：当写一个 volatile 变量时，`JMM` 会把该线程对应的本地内存中的共享变量刷新到主内存。 `volatile` 读的内存语义如下：当读一个 volatile 变量时，`JMM` 会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。
(c) 若我们把 `volatile` 写和 `volatile` 读这两个步骤综合起来看的话，在读线程 B 读一个 `volatile` 变量后，写线程 A 在写这个 `volatile` 变量之前所有可见的共享变量的值都将立即变得对读线程 B 可见。
(d) JSR-133 专家组决定增强 `volatile` 的内存语义：严格限制编译器和处理器对 `volatile` 变量与普通变量的重排序，确保 `volatile` 的写 - 读和监视器的释放 - 获取一样，具有相同的内存语义。
(e) `JMM` 针对编译器制定的 `volatile` 重排序规则表：
(1) 当第二个操作是 `volatile` 写时，不管第一个操作是什么，都不能重排序。这个规则确保 `volatile` 写之前的操作不会被编译器重排序到 `volatile` 写之后。
(2) 当第一个操作是 `volatile` 读时，不管第二个操作是什么，都不能重排序。这个规则确保 volatile 读之后的操作不会被编译器重排序到 `volatile` 读之前。
(3) 当第一个操作是 `volatile` 写，第二个操作是 `volatile` 读时，不能重排序。

**锁**。当线程释放锁时，`JMM` 会把该线程对应的本地内存中的共享变量刷新到主内存中。当线程获取锁时，`JMM` 会把该线程对应的本地内存置为无效，从而使得被监视器保护的临界区代码必须要从主内存中去读取共享变量。
(a) `CAS` 同时具有 `volatile` 读和 `volatile` 写的内存语义。
(b) `AQS`，非阻塞数据结构和原子变量类（`java.util.concurrent.atomic` 包中的类）都是基于 `volatile`变量的读/写及 `CAS` 操作实现。而前三者又构成了`java`并发包中的同步器的基础。

 **`final`**。与前面介绍的锁和 `volatile` 相比较，对 `final` 域的读和写更像是普通的变量访问。对于 `final` 域，编译器和处理器要遵守两个重排序规则：(1) 在构造函数内对一个 `final` 域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。(2) 初次读一个包含 `final` 域的对象的引用，与随后初次读这个`final` 域，这两个操作之间不能重排序。
(a) 写 final 域的重排序规则会要求译编器在 `final` 域的写之后，构造函数 `return` 之前，插入一个 `StoreStore` 障屏。读 final 域的重排序规则要求编译器在读 `final` 域的操作前面插入一个 `LoadLoad` 屏障。
(b) 当`final` 域为一个引用类型，比如它引用一个 `int` 型的数组对象。此时写`final`域的重排序规则对编译器和处理器增加了如下约束：在构造函数内对一个 `final` 引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。
(c) JSR-133 专家组增强了 `final` 的语义。通过为 `final` 域增加写和读重排序规则，可以为 `java` 程序员提供初始化安全保证：只要对象是正确构造的（被构造对象的引用在构造函数中没有“逸出”），那么不需要使用同步（指 `lock` 和 `volatile` 的使用），就可以保证任意线程都能看到这个 `final` 域在构造函数中被初始化之后的值。

**总结**。**(a)** 由于常见的处理器内存模型比 `JMM` 要弱，`java` 编译器在生成字节码时，会在执行指令序列的适当位置插入内存屏障来限制处理器的重排序。同时，由于各种处理器内存模型的强弱并不相同，为了在不同的处理器平台向程序员展示一个一致的内存模型，`JMM` 在不同的处理器中需要插入的内存屏障的数量和种类也不相同。
**(b)** 顺序一致性内存模型是一个理论参考模型，`JMM` 和处理器内存模型在设计时通常会把顺序一致性内存模型作为参照。
**(c)** `JMM` 是一个语言级的内存模型，处理器内存模型是硬件级的内存模型，顺序一致性内存模型是一个理论参考模型。
**(d)** 从 JMM 设计者的角度来说，在设计 `JMM` 时，需要考虑两个关键因素：
(1) 程序员对内存模型的使用。程序员希望内存模型易于理解，易于编程。程序员希望基于一个强内存模型来编写代码。
(2) 编译器和处理器对内存模型的实现。编译器和处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。编译器和处理器希望实现一个弱内存模型。
由于这两个因素互相矛盾，所以 JSR-133 专家组在设计 JMM 时的核心目标就是找到一个好的平衡点：一方面要为程序员提供足够强的内存可见性保证；另一方面，对编译器和处理器的限制要尽可能的放松。
**(e)** Java 程序的内存可见性保证按程序类型可以分为下列三类：
(1) 单线程程序。单线程程序不会出现内存可见性问题。编译器，`runtime` 和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。
(2) 正确同步的多线程程序。正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。这是 `JMM` 关注的重点，`JMM` 通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。
(3) 未同步 / 未正确同步的多线程程序。`JMM` 为它们提供了最小安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值。

以上内容大部分自文献[1]，并整合了个人的思考。



参考文献

[1]. 深入理解Java内存模型  程晓明
[2]. JSR-133_JavaTM Memory Model and Thread Specification
[3]. 周志明. 深入理解 Java 虚拟机一 JVM 高级特性与最佳实践[J]. 2014.