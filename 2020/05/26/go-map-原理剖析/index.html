<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<meta name="theme-color" content="#222">
<style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 2px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>








<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/avastar-circle-32x32.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/avastar-circle-16x16.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="go,">










<meta name="description" content="Go 语言提供了 map 内置数据类型，map 在实际开发中应用较为广泛。但在使用 Go map 时难免会有一些疑问，比如 map 底层是如何实现的、map 是如何支持泛型的、 map 中查询不存在的键为什么返回对应值类型的零值、map 遍历为什么没有保证顺序、 map 的元素为什么不能直接寻址以及 map 检测多个 go routine 并发读写的原理是什么等等。因此，本文通过阐述 go run">
<meta name="keywords" content="go">
<meta property="og:type" content="article">
<meta property="og:title" content="go map 原理剖析">
<meta property="og:url" content="https://qtozeng.top/2020/05/26/go-map-原理剖析/index.html">
<meta property="og:site_name" content="一抹光辉油彩">
<meta property="og:description" content="Go 语言提供了 map 内置数据类型，map 在实际开发中应用较为广泛。但在使用 Go map 时难免会有一些疑问，比如 map 底层是如何实现的、map 是如何支持泛型的、 map 中查询不存在的键为什么返回对应值类型的零值、map 遍历为什么没有保证顺序、 map 的元素为什么不能直接寻址以及 map 检测多个 go routine 并发读写的原理是什么等等。因此，本文通过阐述 go run">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-05-26T13:16:11.010Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="go map 原理剖析">
<meta name="twitter:description" content="Go 语言提供了 map 内置数据类型，map 在实际开发中应用较为广泛。但在使用 Go map 时难免会有一些疑问，比如 map 底层是如何实现的、map 是如何支持泛型的、 map 中查询不存在的键为什么返回对应值类型的零值、map 遍历为什么没有保证顺序、 map 的元素为什么不能直接寻址以及 map 检测多个 go routine 并发读写的原理是什么等等。因此，本文通过阐述 go run">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://qtozeng.top/2020/05/26/go-map-原理剖析/">





  <title>go map 原理剖析 | 一抹光辉油彩</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?32c9335b479b9d4ab2d32b6e9dd59ed8";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->




</head>
<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">一抹光辉油彩</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description"></h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://qtozeng.top/2020/05/26/go-map-原理剖析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zeng Qiaoqiao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一抹光辉油彩">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">go map 原理剖析</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-26T21:13:11+08:00">
                2020-05-26
              </time>
            

            

            


          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index">
                    <span itemprop="name">go</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  14,652
                </span>
              words

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  61
                </span>
              mins
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Go 语言提供了 map 内置数据类型，map 在实际开发中应用较为广泛。但在使用 Go map 时难免会有一些疑问，比如 map 底层是如何实现的、map 是如何支持泛型的、 map 中查询不存在的键为什么返回对应值类型的零值、map 遍历为什么没有保证顺序、 map 的元素为什么不能直接寻址以及 map 检测多个 go routine 并发读写的原理是什么等等。因此，本文通过阐述 go runtime 中 map 的实现原理来解决这些疑问。</p>
<a id="more"></a>
<p>注意，本文并非 map 的使用或介绍教程，因此你需要具备一定基础知识，可以从<a href="https://tour.golang.org/moretypes/19" target="_blank" rel="noopener">这里</a>和<a href="https://blog.golang.org/maps" target="_blank" rel="noopener">这里</a>了解。另外，本文剖析的 Go 源码的版本是 go1.12 ，但事实上相近的不同版本差距并不大，读者可以阅读<a href="https://github.com/golang/go/blob/release-branch.go1.12/src/runtime/map.go" target="_blank" rel="noopener">源码</a>以更加细致地了解。具体地，本文首先通过介绍 Go map 源码中一些关键的结构声明和字段以阐述 map 底层大致是如何实现的，然后再结合源码介绍 map 的几个典型的操作，如创建、查询、扩容以及删除和遍历操作实现的基本原理。事实上，若读者熟悉 Java 的 HashMap 或者 C++ 的 unorderedMap 的源码，那也能快速上手 Go map 实现原理，其大致是类似的，只不过因数据结构不同，使得具体实现有些区别。另外，需要提醒的是，本文篇幅非常长，因此，若读者没有足够的时间，则建议阅读第一小节『map 基本实现原理』以对 Go map 的大致了解，它基本是足够的。其次，每一个小节（相当于 map 的一种操作）的开头部分都阐述了对应操作的大致实现原理，这可以使得读者能够不深入源码而对实现的大致原理有更进一步的了解。</p>
<h2 id="map-基本实现原理"><a href="#map-基本实现原理" class="headerlink" title="map 基本实现原理"></a>map 基本实现原理</h2><p>在使用 map 编程时，你是否思考过 map 是如何实现泛型的——键类型支持几乎所有类型（除了 slice、map 和  function 等），而值类型支持所有类型。但到 Go1.4 为止，Go 未提供泛型支持。因此你可能会觉得 map 的签名包含 interface{} 类型，实际上并不是。而且，不同于 Java 和 C++ 所实现的 map 的泛型支持方式，Java 中的 HashMap 所支持的泛型仅能添加对象类型（基本类型需要装箱），并且未将类型信息保留到运行期（泛型擦除），而 C++ 中的 unorderedMap 则实现了真正的泛型，换言之，每一种键值类型的 map 通过代码生成技术都会被编译成不同的类型（因此，在可执行二进制文件中充斥着大量的类型信息）。而 Go 则集成了二者的优点。具体地，它没有 C++ 所面临的类型信息膨胀问题，因为它为不同键值类型的 map 只生成不同的 <a href="https://github.com/golang/go/blob/release-branch.go1.12/src/runtime/type.go#L363" target="_blank" rel="noopener">maptype</a> 结构，而且也不会有类型限制（或者频繁装箱和拆箱而遭受性能损失）。</p>
<h3 id="map-实现原理概述"><a href="#map-实现原理概述" class="headerlink" title="map 实现原理概述"></a>map 实现原理概述</h3><p>Go map 由编译器和 runtime 协作实现。概括而言，包括如下两点：</p>
<p>关于数据结构。map 使用数组+链表的实现方式（Java  HashMap 采用数组+链表/红黑树，而 C++  unorderedMap 采用数组+链表），即采用拉链法来解决 key 的冲突问题，其中数组位置被称为 bucket，且初始 bucket 数量为 2^B（即大于用户指定的容量的最小的 2 的指数幂）。另外使用 cell（源码中没有明确这个称呼）来容纳具体键值对信息 ，且一个 bucket 只能装载 8（bucketCnt） 个 cell，当 bucket 中没有更多空间容纳添加的键值对时，则在此 bucket 后动态挂一个称为 overflow 的 bucket，以此类推。其中 bucket 的映射算法使用 key 的 hash 值的低 B 位的值，而 cell 的映射算法使用 key 的 hash 值的高 8 位的值。</p>
<p>关于扩容。扩容的目的是提高检索、插入和删除的效率，而扩容手段采用的是渐近式扩容或者增量扩容（原理和实现类似于 redis 的渐近式 rehash ），即每次执行插入或修改以及删除操作时最多迁移 2 个 bucket。一方面，当整个 map 中包含过多数量的键值对时，即当前键值对数量超过负载因子 6.5（loadFactor），导致此种情形出现的原因是创建的 bucket 数量过少（元素过多），因此将现有容量（即 bucket 的数量）扩大为原来的一倍，在这种情况下，旧的 bucket 中的元素根据其 key 的 hash 值的第 B+1 位是否为 0，以决定其被迁移到扩容后的 bucket 数组的前半部分还是后半部分；另一方面，当整个 map 包含过多 overflow bucket 时，导致此种情形出现的原因是频繁的插入和删除操作创建大量的 overflow bucket，因此开辟一个新的 bucket ，将旧的 bucket 元素以相同的映射方式迁移重组到新的 bucket，通过将 overflow bucket 中的键值对整合到 bucket 中，使得 bucket 中的键值对排列更紧凑，以节省空间并提高 bucket 利用率。事实上，因为采用拉链法，因此过多 overflow bucket 使得元素查找效率急剧下降（不能保证接近O(1)的复杂度）。</p>
<h3 id="map-实现涉及的关键数据结构"><a href="#map-实现涉及的关键数据结构" class="headerlink" title="map 实现涉及的关键数据结构"></a>map 实现涉及的关键数据结构</h3><p>结合源码来看，map 的 runtime 实现主要及到 <a href="https://github.com/golang/go/blob/release-branch.go1.12/src/runtime/map.go#L115" target="_blank" rel="noopener">hmap</a> 和 <a href="https://github.com/golang/go/blob/release-branch.go1.12/src/runtime/map.go#L149" target="_blank" rel="noopener">bmap</a> 两个数据结构，hmap 代表 map header 数据结构，具体如下所示。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	count     <span class="keyword">int</span>    <span class="comment">// map 键值对数目。必须处于第一个位置，以使得 len() 函数可以正确获取其长度</span></span><br><span class="line">	flags     <span class="keyword">uint8</span>  <span class="comment">// map 的状态，如正在被某个迭代器遍历，或者被某个 go routine 写入</span></span><br><span class="line">	B         <span class="keyword">uint8</span>  <span class="comment">// 容量为 2^B，但只能容纳 loadFactor(6.5) * 2^B 个元素</span></span><br><span class="line">	noverflow <span class="keyword">uint16</span> <span class="comment">// overflow buckets 的大致数量</span></span><br><span class="line">	hash0     <span class="keyword">uint32</span> <span class="comment">// hash 种子，用于计算 key 的 hash 值</span></span><br><span class="line"></span><br><span class="line">	buckets    unsafe.Pointer <span class="comment">// 指向 buckets 数组，大小为 2^B，若 count==0，则其为 nil.</span></span><br><span class="line">	oldbuckets unsafe.Pointer <span class="comment">// 扩容时使用，oldbuckets 指向旧的 bucket 数组，新的 buckets 长度是 oldbuckets 的两倍</span></span><br><span class="line">	nevacuate  <span class="keyword">uintptr</span>        <span class="comment">// 扩容时使用，元素迁移进度，小于此索引的 buckets 表示已迁移完成</span></span><br><span class="line"></span><br><span class="line">	extra *mapextra <span class="comment">// 可选字段，当 key 和 value 可以被 inline 时，会使用此字段</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// mapextra 包含一些没有包含在 map 中的字段</span></span><br><span class="line"><span class="keyword">type</span> mapextra <span class="keyword">struct</span> &#123;</span><br><span class="line">	overflow    *[]*bmap <span class="comment">// 指向一个 bmap 地址切片的指针，表示 overflow bucket</span></span><br><span class="line">	oldoverflow *[]*bmap <span class="comment">// 同上，扩容时使用，表示旧的 overflow bucket</span></span><br><span class="line"></span><br><span class="line">	nextOverflow *bmap <span class="comment">// 指向空闲的 overflow bucket 的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> hmap 定义很清晰，但需说明的是，mapextra 源码中注释说若 map 的 key 和 value 都不包含指针，并且可以被 inline（不大于 128 字节），则可使用 mapextra 来存储 overflow bucket，以避免 GC 扫描整个 map。但考虑到 bmap 有一个 overflow 的指针字段（下文），因此就把 overflow 移动到  <code>hmap.mapextra.overflow</code>以及<code>hmap.mapextra.oldoverflow</code> 字段。换言之，<code>mapextra.overflow</code> 包含的是 <code>hmap.buckets</code>的 overflow buckets，而<code>mapextra.oldoverflow</code>则包含的是<code>hmap.odlbuckets</code>的 overflow  buckets。</p>
<p>另外，bmap 表示 bucket 数据结构，即数组元素的表示，其在 runtime 中的定义如下。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 存储此 bucket 中的 key 的 top hash 值（高8位）</span></span><br><span class="line">	<span class="comment">// 并且，若 tophash[0] &lt; minTopHash，则表示此 bucket 正在被迁移（处于扩容状态）</span></span><br><span class="line">	tophash [bucketCnt]<span class="keyword">uint8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事实上，bmap 在<a href="https://github.com/golang/go/blob/release-branch.go1.12/src/cmd/compile/internal/gc/reflect.go#L82" target="_blank" rel="noopener">编译期</a>会通过反射给它增加几个字段，因此，它真正的结构如下所示。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	tophash [bucketCnt]<span class="keyword">uint8</span></span><br><span class="line">    keys	[<span class="number">8</span>]keytype 	 <span class="comment">// 存储在此 bucket 中 8 个连续的 key</span></span><br><span class="line">    values	[<span class="number">8</span>]valuetype <span class="comment">// 存储在此 bucket 中 8 个连续的 value</span></span><br><span class="line">    padding	uniptr		 <span class="comment">// 内存对齐字段（可选）</span></span><br><span class="line">    overflow uniptr		 <span class="comment">// overflow bucket 指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bmap 结构也容易理解，值得注意的是，它的 key/value 的存储的方式，并不是交叉存储，而是分开存储，显然这种存储方式可以压缩 padding 的大小。因此，bmap 的内存结构大致如下所示。其中 hobH 表示元素 key 值的 hash 值的高 8 位。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+-------------------------------------------------------+</span><br><span class="line">| hobH | hobH | hobH | hobH | hobH | hobH | hobH | hobH |</span><br><span class="line">+-------------------------------------------------------+</span><br><span class="line">|                         key[8]                        |</span><br><span class="line">+-------------------------------------------------------+</span><br><span class="line">|                         val[8]                        |</span><br><span class="line">+-------------------------------------------------------+</span><br><span class="line">|                    padding(optional)                  |</span><br><span class="line">+-------------------------------------------------------+</span><br><span class="line">|                        *overflow                      |</span><br><span class="line">+-------------------------------------------------------+</span><br></pre></td></tr></table></figure>
<p>现在，我们似乎还未找到和 map 支持泛型相关的代码。可以看一下创建 map 的函数原型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makemap</span><span class="params">(t *maptype, hint <span class="keyword">int</span>, h *hmap)</span> *<span class="title">hmap</span></span></span><br></pre></td></tr></table></figure>
<p>可以看到 <a href="https://github.com/golang/go/blob/release-branch.go1.12/src/runtime/type.go#L363" target="_blank" rel="noopener">maptype</a> 类型的参数 t 被传入创建函数。事实上，maptype 存储了关于此 map 的 key 和 value 的详细信息，对于每一个不同键值对类型的 map，在编译时期会创建一个对应的 maptype。其定义如下。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> maptype <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ        _type </span><br><span class="line">	key        *_type <span class="comment">// key 的内部类型</span></span><br><span class="line">	elem       *_type <span class="comment">// value 的内部类型</span></span><br><span class="line">    bucket     *_type <span class="comment">// bucket(bmap) 的内部类型</span></span><br><span class="line">	keysize    <span class="keyword">uint8</span>  <span class="comment">// key 的大小</span></span><br><span class="line">	valuesize  <span class="keyword">uint8</span>  <span class="comment">// value 的大小</span></span><br><span class="line">	bucketsize <span class="keyword">uint16</span> <span class="comment">// bucket 的大小</span></span><br><span class="line">	flags      <span class="keyword">uint32</span> <span class="comment">// key 或 value 的状态，比如 key 存储值还是指针值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，每个被创建的 maptype 都包含关于从 key 到 elem 的 map 属性的详细信息。其中  <a href="https://github.com/golang/go/blob/release-branch.go1.12/src/runtime/type.go#L28" target="_blank" rel="noopener">_type</a> 类型可称为类型描述符。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> _type <span class="keyword">struct</span> &#123;</span><br><span class="line">	size       <span class="keyword">uintptr</span></span><br><span class="line">	ptrdata    <span class="keyword">uintptr</span></span><br><span class="line">	hash       <span class="keyword">uint32</span></span><br><span class="line">	tflag      tflag</span><br><span class="line">	align      <span class="keyword">uint8</span></span><br><span class="line">	fieldalign <span class="keyword">uint8</span></span><br><span class="line">	kind       <span class="keyword">uint8</span></span><br><span class="line">	alg        *typeAlg</span><br><span class="line">	gcdata    *<span class="keyword">byte</span></span><br><span class="line">	str       nameOff</span><br><span class="line">	ptrToThis typeOff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> _type 类型（类型描述符）包含其所代表类型的详细信息，如大小等。另外，我们可通过其包含的 typeAlg 字段来比较两个类型的值是否相等（equal 函数），以及取得此类型的值的 hash 值（hash 函数）。typeAlg 的结构定义如下所示。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> typeAlg <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// (ptr to object, seed) -&gt; hash</span></span><br><span class="line">	hash <span class="function"><span class="keyword">func</span><span class="params">(unsafe.Pointer, <span class="keyword">uintptr</span>)</span> <span class="title">uintptr</span></span></span><br><span class="line"><span class="function">	// <span class="params">(ptr to object A, ptr to object B)</span> -&gt; ==?</span></span><br><span class="line"><span class="function">	<span class="title">equal</span> <span class="title">func</span><span class="params">(unsafe.Pointer, unsafe.Pointer)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="map-实现涉及的关键常量和-util-函数"><a href="#map-实现涉及的关键常量和-util-函数" class="headerlink" title="map 实现涉及的关键常量和 util 函数"></a>map 实现涉及的关键常量和 util 函数</h3><p>至此，读者应该清楚 Go map 泛型支持的实现原理了。在正式阐述 map 中各具体操作的逻辑前，为了帮助理解，我们先简单介绍一些关键常量以及一些工具类函数和方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// bucket 包含的 cell 的数量 1 &lt;&lt; 3 = 8</span></span><br><span class="line">	bucketCntBits = <span class="number">3</span></span><br><span class="line">	bucketCnt     = <span class="number">1</span> &lt;&lt; bucketCntBits</span><br><span class="line"></span><br><span class="line">	<span class="comment">// map 的负载因子，默认是 6.5.</span></span><br><span class="line">	<span class="comment">// 即当 map 中包含的元素大于 (loadFactorFum/loadFactorDen) *  2^B 时，则进行扩容</span></span><br><span class="line">	loadFactorNum = <span class="number">13</span></span><br><span class="line">	loadFactorDen = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 能够 inline 的 key 和 value 的大小</span></span><br><span class="line">	maxKeySize   = <span class="number">128</span></span><br><span class="line">	maxValueSize = <span class="number">128</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// dataOffset 即为 bmap 结构的大小，但包含对齐的字节。</span></span><br><span class="line">	dataOffset = unsafe.Offsetof(<span class="keyword">struct</span> &#123;</span><br><span class="line">		b bmap</span><br><span class="line">		v <span class="keyword">int64</span></span><br><span class="line">	&#125;&#123;&#125;.v)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// tophash 的一些特殊取值。</span></span><br><span class="line">	emptyRest      = <span class="number">0</span> <span class="comment">// cell 是空的，而且在此 cell 后面不存在容纳元素的 cell.</span></span><br><span class="line">	emptyOne       = <span class="number">1</span> <span class="comment">// cell 是空的</span></span><br><span class="line">	evacuatedX     = <span class="number">2</span> <span class="comment">// 此 cell 所对应的 key/value 被迁移到新的 bucket 数组的前半部分： hash&amp;bucketCnt==0</span></span><br><span class="line">	evacuatedY     = <span class="number">3</span> <span class="comment">// 此 cell 所对应的 key/value 被迁移到新的 bucket 数组的后半部分： hash&amp;bucketCnt==1</span></span><br><span class="line">	evacuatedEmpty = <span class="number">4</span> <span class="comment">// cell 是空的, 而且此 bucket 对应的 cell 已被迁移</span></span><br><span class="line">	minTopHash     = <span class="number">5</span> <span class="comment">// 处于正常状态的 bucket 的最小的 tophash 值。若计算的值小于此值，则直接加上此值作为新的 topHash</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// hmap.flags 的状态取值</span></span><br><span class="line">	iterator     = <span class="number">1</span> <span class="comment">// 有迭代器正在使用（遍历） hmap.buckets</span></span><br><span class="line">	oldIterator  = <span class="number">2</span> <span class="comment">// 有迭代器正在使用（遍历） hmap.oldbuckets</span></span><br><span class="line">	hashWriting  = <span class="number">4</span> <span class="comment">// 有迭代器正在写入或修改 hmap。此字段用于防止 go routine 并发读写 map</span></span><br><span class="line">	sameSizeGrow = <span class="number">8</span> <span class="comment">// 当前 map 正执行等量扩容操作。即此时扩容的原因是 overflow buckets 过多</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 迭代 map 时使用的哨兵 bucket ID，表示当前迭代的 bucket 未处于扩容状态，或者即使处于扩容状态，也已经迁移完毕</span></span><br><span class="line">	noCheck = <span class="number">1</span>&lt;&lt;(<span class="number">8</span>*sys.PtrSize) - <span class="number">1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 bucket 数目。如 B = 4，则返回 10000</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bucketShift</span><span class="params">(b <span class="keyword">uint8</span>)</span> <span class="title">uintptr</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">uintptr</span>(<span class="number">1</span>) &lt;&lt; b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回 bucket 数目的掩码值。如 B = 4，则返回 1111</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bucketMask</span><span class="params">(b <span class="keyword">uint8</span>)</span> <span class="title">uintptr</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> bucketShift(b) - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回指定 key 的 hash 值所对应的 tophash，即获取 hash 值的高 8 位值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tophash</span><span class="params">(hash <span class="keyword">uintptr</span>)</span> <span class="title">uint8</span></span> &#123;</span><br><span class="line">	top := <span class="keyword">uint8</span>(hash &gt;&gt; (sys.PtrSize*<span class="number">8</span> - <span class="number">8</span>))</span><br><span class="line">	<span class="keyword">if</span> top &lt; minTopHash &#123;</span><br><span class="line">		top += minTopHash</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> top</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  返回此 bucket 是否已经被迁移完毕</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evacuated</span><span class="params">(b *bmap)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	h := b.tophash[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">return</span> h &gt; emptyOne &amp;&amp; h &lt; minTopHash</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回此 maptype 对应类型值的 overflow 指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *bmap)</span> <span class="title">overflow</span><span class="params">(t *maptype)</span> *<span class="title">bmap</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> *(**bmap)(add(unsafe.Pointer(b), <span class="keyword">uintptr</span>(t.bucketsize)-sys.PtrSize))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置 maptype 对应类型值的 overflow 的指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *bmap)</span> <span class="title">setoverflow</span><span class="params">(t *maptype, ovf *bmap)</span></span> &#123;</span><br><span class="line">	*(**bmap)(add(unsafe.Pointer(b), <span class="keyword">uintptr</span>(t.bucketsize)-sys.PtrSize)) = ovf</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回 bucket 中存储 key 的起始偏移位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *bmap)</span> <span class="title">keys</span><span class="params">()</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> add(unsafe.Pointer(b), dataOffset)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="map-创建函数"><a href="#map-创建函数" class="headerlink" title="map 创建函数"></a>map 创建函数</h2><p>map 创建逻辑比较简单。对应的函数为 <a href="https://github.com/golang/go/blob/release-branch.go1.12/src/runtime/map.go#L305" target="_blank" rel="noopener">makmap</a>，首先判断用户传入的大小值是否合法，然后创建 hmap 并初始化 map，接下来计算 <code>hmap.B</code> 的大小，即大于传入的 map 大小的最小的 2 的整数幂，最后为 hmap 创建 bmap，即分配一段连续的内存空间来存储元素。其源码如下。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makemap</span><span class="params">(t *maptype, hint <span class="keyword">int</span>, h *hmap)</span> *<span class="title">hmap</span></span> &#123;</span><br><span class="line">	<span class="comment">// t 存储 map 类型信息， hint 表示用户创建的 map 的大小</span></span><br><span class="line">	<span class="comment">// h 若不为 nil，则直接在 h 中创建新的 map，且若 h.buckets 也不为 nil，则其指向的 bucket 即为第一个 bucket 地址</span></span><br><span class="line">	<span class="comment">// 1. 判断 hint 大小是否合法，不能超过最大分配内存，也不能溢出</span></span><br><span class="line">	mem, overflow := math.MulUintptr(<span class="keyword">uintptr</span>(hint), t.bucket.size)</span><br><span class="line">	<span class="keyword">if</span> overflow || mem &gt; maxAlloc &#123;</span><br><span class="line">		hint = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2. 初始化 hmap，并确定其 hash 种子的值</span></span><br><span class="line">	<span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">		h = <span class="built_in">new</span>(hmap)</span><br><span class="line">	&#125;</span><br><span class="line">	h.hash0 = fastrand()</span><br><span class="line">	<span class="comment">// 3. 计算 B 的值，即大于传入的 map 大小的最小的 2 的整数幂</span></span><br><span class="line">	B := <span class="keyword">uint8</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> overLoadFactor(hint, B) &#123;</span><br><span class="line">		B++</span><br><span class="line">	&#125;</span><br><span class="line">	h.B = B</span><br><span class="line">	<span class="comment">// 4. 若 B=0，则延迟分配 bucket，否则直接开辟内存空间</span></span><br><span class="line">	<span class="keyword">if</span> h.B != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> nextOverflow *bmap</span><br><span class="line">		h.buckets, nextOverflow = makeBucketArray(t, h.B, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">if</span> nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">			h.extra = <span class="built_in">new</span>(mapextra)</span><br><span class="line">			h.extra.nextOverflow = nextOverflow</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是，makemap 函数返回值是 *hmap 指针类型（不同于 slice，其返回的是 slice 结构体），因此，当将 hmap 作为函数参数时，在函数内部对参数 map 的修改会反映到原始的 map 变量，而不需要像 slice 一样要返回修改后的 slice。</p>
<h2 id="map-元素查询"><a href="#map-元素查询" class="headerlink" title="map 元素查询"></a>map 元素查询</h2><p>map 的元素查询关键点在于 bucket 的映射方法以及 cell 的映射方法。对应的函数为 <a href="https://github.com/golang/go/blob/release-branch.go1.12/src/runtime/map.go#L396" target="_blank" rel="noopener">mapaccess1</a>，其大致过程如下：首先判断若 map 为空或者大小为 0，则直接返回 map 元素值类型的零值。然后，检测是否存在 go routine 并发读写 map 的情况。接下来的执行过程大致为先定位 bucket，再定位 cell。具体地，先获取当前查询的 key 的 hash 值，然后根据 hash 值的低 B 位的值计算 key 所映射的 bucket，同时，计算当前 key 的 tophash 值用于后续映射 bucket 中的 cell。接下来，执行两层 for 循环，外层循环遍历当前 bucket 链（因为可能存在 overflow bucket），内层循环遍历 bucket 的 8 个 cell ，根据 tophash 值定位对应的 cell。需要注意的是，map 元素查询过程可能和 map 扩容操作的元素迁移过程重叠，此时，若旧的 bucket 未迁移完毕，则需要到对应的旧的 bucket 中执行上述的两层 for 循环。</p>
<p>在介绍 map 元素查询源码逻辑前，先简单介绍几个频繁使用的 bucket 定位以及 key 和 value 定位的计算方式。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br></pre></td></tr></table></figure>
<p>上面为 bucket 定位方式。其中 m 为 map 的掩码值，hash 为 key 的 hash 值，因此 <code>m&amp;hash</code>可以计算出对应的 bucket 在数组中的索引，也即需要跳过的 bucket 的数目，最后加上 hmap 中 buckets 指针的偏移，可得到 key 所映射的 bucket 的地址。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k := add(unsafe.Pointer(b), dataOffset+i*<span class="keyword">uintptr</span>(t.keysize))</span><br></pre></td></tr></table></figure>
<p>上面为 key 定位方式。其中 dataOffset 为 bucket 中 key 的起始偏移，因此 <code>dataOffset+i*uintptr(t.keysize)</code>可以跳过指定数量的 key，最后通过加上当前 bucket 的地址偏移以获取对应的 key 所映射的 cell 的地址。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="keyword">uintptr</span>(t.keysize)+i*<span class="keyword">uintptr</span>(t.valuesize))</span><br></pre></td></tr></table></figure>
<p>上面为 key 所关联的 value 定位方式。显然，其定位过程同 key 类似，只不过需要加上位于其前面的 8 个 key 占用的地址空间。</p>
<p>最后，在 map 中通过指定 key 查找 value 的方法 mapaccess1 的源码解析如下，为了更清楚阐述，删除了部分不太相关的逻辑。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapaccess1</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">    <span class="comment">// 编译器将用户程序的 v := map[key] 映射到此函数调用</span></span><br><span class="line">	<span class="comment">// t 存储 map 类型信息， h 表示被查询的 map，而 key 表示查询的元素的 key 值</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="comment">// 1. 若 map 为空，则返回对应元素值类型的零值</span></span><br><span class="line">	<span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> t.hashMightPanic() &#123;</span><br><span class="line">			t.key.alg.hash(key, <span class="number">0</span>) <span class="comment">// see issue 23734</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2. 禁止 go routine 并发读写 map</span></span><br><span class="line">	<span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">"concurrent map read and map write"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 3. 获取 key 对应的 typeAlg 字段，以用于计算其 hash 值以及判断两个 key 是否相同</span></span><br><span class="line">	alg := t.key.alg</span><br><span class="line">	hash := alg.hash(key, <span class="keyword">uintptr</span>(h.hash0))</span><br><span class="line">	<span class="comment">// 4. 计算 hmap.B 的掩码值，然后定位到对应的 bucket</span></span><br><span class="line">	m := bucketMask(h.B)</span><br><span class="line">	b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">	<span class="comment">// 5. 若 map 正在执行扩容过程，则进一步判断是否为等容量扩容，</span></span><br><span class="line">	<span class="comment">// 若非等量扩容（增大为原容量的两倍），则更新上述 m 的值为原来的一半，</span></span><br><span class="line">	<span class="comment">// 同时，定位查询 key 在旧的 bucket 数组中对应的 bucket，</span></span><br><span class="line">	<span class="comment">// 最后，若此对应的 bucket 未迁移完成，则后续将在此 bucket 中检索 key 对应的元素值</span></span><br><span class="line">	<span class="keyword">if</span> c := h.oldbuckets; c != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">			m &gt;&gt;= <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		oldb := (*bmap)(add(c, (hash&amp;m)*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">		<span class="keyword">if</span> !evacuated(oldb) &#123;</span><br><span class="line">			b = oldb</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 6. 计算当前 key 的 tophash 值</span></span><br><span class="line">	top := tophash(hash)</span><br><span class="line">	<span class="comment">// 7. 在指定的 bucket 链（若包含有 overflow bucket）上根据 tophash 值查找对应的 key</span></span><br><span class="line">bucketloop:</span><br><span class="line">	<span class="comment">// 7.1 外层循环遍历 bucket 链上的每个 bucket，</span></span><br><span class="line">	<span class="comment">// 其中 overflow(t) 表示获取下一个 overflow bucket</span></span><br><span class="line">	<span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">		<span class="comment">// 7.2 内层循环遍历 bucket 包含的每个 cell</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">			<span class="comment">// 7.3 若 cell 存储的 tophash 值和当前 key 的 tophash 不同，</span></span><br><span class="line">			<span class="comment">// 并且为 emptyRest，则表明当前的 bucket 已经被迁移完成，则直接中止循环</span></span><br><span class="line">			<span class="comment">// 否则，继续查看下一个 cell</span></span><br><span class="line">			<span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">				<span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line">					<span class="keyword">break</span> bucketloop</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 7.4 获取当前的 cell 中存储的 key，且若 key 为指针，则解引用取值</span></span><br><span class="line">			k := add(unsafe.Pointer(b), dataOffset+i*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">			<span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">				k = *((*unsafe.Pointer)(k))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 7.5 若当前 cell 的 key 值与查询的 key 值相等，</span></span><br><span class="line">			<span class="comment">// 则计算当前 cell 的 key 所关联的 value 所存储的地址</span></span><br><span class="line">			<span class="comment">// 类似地，若 value 为指针，则解引用取值，最后返回此 value</span></span><br><span class="line">			<span class="keyword">if</span> alg.equal(key, k) &#123;</span><br><span class="line">				v := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="keyword">uintptr</span>(t.keysize)+i*<span class="keyword">uintptr</span>(t.valuesize))</span><br><span class="line">				<span class="keyword">if</span> t.indirectvalue() &#123;</span><br><span class="line">					v = *((*unsafe.Pointer)(v))</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> v</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 7.6 否则，说明此 key 在当前 map 的所有 bucket 中未找到，返回 map 元素值类型的零值</span></span><br><span class="line">	<span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，还有两点需要补充说明。首先，从源码中看，map  为源码中两种不同的获取指定 key 所对应 value 的方式实现了两个方法 mapaccess1 和 mapaccess2，其实现逻辑大致类似，只不过 mapaccess2 对应的是源码中<code>v, ok := map[key]</code>的访问操作；其次，为了提升执行效率，对于具体的 key 类型，编译器将查找、插入、删除操作所对应的函数用替换为更具体函数。比如，对于 key 为 uint32 类型，其调用 <a href="https://github.com/golang/go/blob/release-branch.go1.12/src/runtime/hashmap_fast.go" target="_blank" rel="noopener">src/runtime/hashmap_fast.go</a> 文件中的 <a href="https://github.com/golang/go/blob/release-branch.go1.12/src/runtime/map_fast32.go#L12" target="_blank" rel="noopener">mapaccess1_fast32(t <em>maptype, h </em>hmap, key uint32) unsafe.Pointer</a> 函数。</p>
<h2 id="map-元素插入或更新"><a href="#map-元素插入或更新" class="headerlink" title="map 元素插入或更新"></a>map 元素插入或更新</h2><p>map 元素插入或更新的实现逻辑和 map 元素查询逻辑有很多重叠的地方。对应函数为 <a href="https://github.com/golang/go/blob/release-branch.go1.12/src/runtime/map.go#L576" target="_blank" rel="noopener">mapassign</a>，其大致执行逻辑为：首先做一些预备工作，比如判断当前 map 是否为 nil 或者容量为 0，是否存在 go routine 并发写，以及计算当前 key 的 hash 值，标记当前 map 处于写入状态等。接下来的三层（也可以认为是两层）循环是整个函数的核心，最外层循环主要考虑到当前 map 是否需要执行扩容操作，因为一旦执行扩容操作，则先前 bucket 中的 key 分布信息会失效，同时，在最外层循环中还会执行定位当前 key 所对应的 bucket 索引操作，而且，若当前确实处于扩容状态，则协助迁移最多两个 bucket。然后，进入到里面的两层循环，此两层循环的逻辑同 mapaccess1 函数的两层循环逻辑类似，第一层遍历 bucket 链以定位具体的 bucket，而第二层遍历每个 bucket 的 8 个 cell，查询当前 key 是否在之前就已经插入过，若是，则更新对应 key 在 tophash 数组中的索引地址、key 存储在 cell 中的地址以及 key 所关联的 value 的地址，最后统一赋值。最后一个部分包含一些收尾工作，比如重置当前 map 的写状态，并返回 key 所关联的 value 的地址，最后由汇编指令将对应的值存储到此指针所指的内存地址。在 map 中通过插入或更新键值对的函数 mapassign 的源码如下，同样，为了更清楚阐述，删除了部分不太相关的逻辑。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapassign</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">	<span class="comment">// 编译器将用户程序的 map[key] = value 映射到此函数调用。</span></span><br><span class="line">	<span class="comment">// t 存储 map 类型信息， h 为对应的 map，而 key 表示被插入或更新元素的 key 值。</span></span><br><span class="line">	<span class="comment">// 那么对应 value 值是如何传入的呢？事实上，赋值的最后一步是由编译器额外生成的汇编指令来完成的。</span></span><br><span class="line">	<span class="comment">// mapassign 返回存储对应值的指针，汇编指令将对应的值存储到此指针所指的内存地址。</span></span><br><span class="line">	<span class="comment">// 1. 若 h == nil，则直接 panic。 var m map[keytype]valuetype 这种情形下 m == nil</span></span><br><span class="line">	<span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">"assignment to entry in nil map"</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="comment">// 2. 同样禁止 go routine 并发写 map</span></span><br><span class="line">	<span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">"concurrent map writes"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 3. 获取 key 对应的 typeAlg 字段，以用于计算其 hash 值以及判断两个 key 是否相同</span></span><br><span class="line">	alg := t.key.alg</span><br><span class="line">	hash := alg.hash(key, <span class="keyword">uintptr</span>(h.hash0))</span><br><span class="line">	<span class="comment">// 4. 标记当前 go routine 正在写 map</span></span><br><span class="line">	h.flags ^= hashWriting</span><br><span class="line">	<span class="comment">// 5. 若 buckets 为空，即创建 map 时指定容量为 0： m := make(map[keytype]valuetype, 0)</span></span><br><span class="line">	<span class="comment">// 则直接创建容量为 1 的 map</span></span><br><span class="line">	<span class="keyword">if</span> h.buckets == <span class="literal">nil</span> &#123;</span><br><span class="line">		h.buckets = newobject(t.bucket) <span class="comment">// newarray(t.bucket, 1)</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 6. again 标签表示由于执行了扩容操作导致 key 的分布信息失效，</span></span><br><span class="line">	<span class="comment">// 因此需要重新走一遍 key 的整个定位过程。</span></span><br><span class="line">again:</span><br><span class="line">	<span class="comment">// 7. 计算当前 key 所映射的 bucket 索引值</span></span><br><span class="line">	bucket := hash &amp; bucketMask(h.B)</span><br><span class="line">	<span class="comment">// 8. 判断当前 map 是否处于扩容状态（包含两种扩容情况），</span></span><br><span class="line">	<span class="comment">// 若是，则先执行 bucket 迁移操作，再执行后续逻辑。</span></span><br><span class="line">	<span class="comment">// 因为 map 扩容时元素迁移是渐近式的，每次插入或修改操作最多迁移两个 bucket</span></span><br><span class="line">	<span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">		growWork(t, h, bucket)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 9. 定位 key 所对应的 bucket 的地址，同时计算出 key 的 tophash 值</span></span><br><span class="line">	b := (*bmap)(unsafe.Pointer(<span class="keyword">uintptr</span>(h.buckets) + bucket*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">	top := tophash(hash)</span><br><span class="line">	<span class="comment">// inserti 指向 key 的 hash 值在 tophash 数组所处的位置</span></span><br><span class="line">	<span class="keyword">var</span> inserti *<span class="keyword">uint8</span></span><br><span class="line">	<span class="comment">// insertk 指向 key 所处的 cell 的位置</span></span><br><span class="line">	<span class="keyword">var</span> insertk unsafe.Pointer</span><br><span class="line">	<span class="comment">// val 指向 key 关联的 value 所处的的位置</span></span><br><span class="line">	<span class="keyword">var</span> val unsafe.Pointer</span><br><span class="line">	<span class="comment">// 10. bucketloop 仍旧为两层循环，外层循环遍历 bucket 链，内层循环遍历每个 bucket 的 8 个 cell，</span></span><br><span class="line">	<span class="comment">// 在其中查找同当前 key 相同的 cell，若查询成功，返回 key 所关联的 value 的地址，跳转到 done，</span></span><br><span class="line">	<span class="comment">// 否则，直接跳出循环，此时 inserti、insertk 以及 val 都为空值。</span></span><br><span class="line">bucketloop:</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">			<span class="comment">// 11. 内层循环。循环遍历当前 bucket 的 8 个 cell，查找当前 key 是否存在。</span></span><br><span class="line">			<span class="comment">// 若通过 tophash 找到一个空位 cell，</span></span><br><span class="line">			<span class="comment">// 则记录对应的空位索引地址、key 所存放的 cell 地址，以及关联的 value 的存放地址。</span></span><br><span class="line">			<span class="comment">// 否则，若发现当前遍历的 tophash 值为 emptyRest，表明此 bucket 及其后续的元素已经被迁移，</span></span><br><span class="line">			<span class="comment">// 因此，直接退出遍历当前 bucket 的循环。</span></span><br><span class="line">			<span class="comment">// 否则，当前遍历的 tophash 值同 key 的 tophash 值不相等，且不为空，也不为 emptyRest 时，</span></span><br><span class="line">			<span class="comment">// 则继续遍历下一个 tophash 值。</span></span><br><span class="line">			<span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">				<span class="keyword">if</span> isEmpty(b.tophash[i]) &amp;&amp; inserti == <span class="literal">nil</span> &#123;</span><br><span class="line">					inserti = &amp;b.tophash[i]</span><br><span class="line">					insertk = add(unsafe.Pointer(b), dataOffset+i*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">					val = add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="keyword">uintptr</span>(t.keysize)+i*<span class="keyword">uintptr</span>(t.valuesize))</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line">					<span class="keyword">break</span> bucketloop</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 12. 找到同当前 key 的 tophash 相等的 cell，即当前 key 在之前有可能已经被插入过，</span></span><br><span class="line">			<span class="comment">// 但还需比较两个 key 值是否相同（因为两个不同的 key 其 tophash 有可能相同）</span></span><br><span class="line">			<span class="comment">// 若 key 值不同，则继续遍历下一个 key。</span></span><br><span class="line">			k := add(unsafe.Pointer(b), dataOffset+i*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">			<span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">				k = *((*unsafe.Pointer)(k))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> !alg.equal(key, k) &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 13. 否则，可以肯定当前 key 之前已插入过，此次操作为更新操作。</span></span><br><span class="line">			<span class="comment">// 则将 key 所对应的值拷贝到对应的 cell，</span></span><br><span class="line">			<span class="comment">// 然后，计算 key 所关联的 value 的地址，跳转到 done，表明此次操作已经完毕</span></span><br><span class="line">			<span class="keyword">if</span> t.needkeyupdate() &#123;</span><br><span class="line">				typedmemmove(t.key, k, key)</span><br><span class="line">			&#125;</span><br><span class="line">			val = add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="keyword">uintptr</span>(t.keysize)+i*<span class="keyword">uintptr</span>(t.valuesize))</span><br><span class="line">			<span class="keyword">goto</span> done</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 14.继续遍历下一个 overflow bucket，直至遍历完所有的 overflow bucket</span></span><br><span class="line">		<span class="comment">// 则跳出循环。</span></span><br><span class="line">		ovf := b.overflow(t)</span><br><span class="line">		<span class="keyword">if</span> ovf == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		b = ovf</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 15. 若程序执行到这里，说明未能找到对应的 key，表明此次操作为插入操作，需要添加一个 key/value 对，</span></span><br><span class="line">	<span class="comment">// 但在正式插入之前，需要先检测是否需要扩容。</span></span><br><span class="line">	<span class="comment">// 具体地，若 map 当前未执行扩容操作，但满足任一扩容条件（增量扩容和等量扩容），</span></span><br><span class="line">	<span class="comment">// 则执行预扩容操作（即扩容的准备工作），hashGrow 完成分配新的 buckets 工作，</span></span><br><span class="line">	<span class="comment">// 并将旧的 buckets 挂到 oldbuckets 字段。</span></span><br><span class="line">	<span class="comment">// 最后，重新执行步骤 7-14，因为扩容后，所有 key 的分布位置都发生了变化，</span></span><br><span class="line">	<span class="comment">// 因此需要重新走一次之前整个的查找定位 key 的过程。</span></span><br><span class="line">	<span class="keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;</span><br><span class="line">		hashGrow(t, h)</span><br><span class="line">		<span class="keyword">goto</span> again <span class="comment">// Growing the table invalidates everything, so try again</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 16. 表明当前 map 不需要扩容（或者已经扩容完毕），此次操作为插入操作，</span></span><br><span class="line">	<span class="comment">// 且在当前 bucket 中未能找到存储 key 的 cell。</span></span><br><span class="line">	<span class="comment">// 因此，需要创建一个 overflow bucket，然后将此 key 插入到第一个 tophash 位置，</span></span><br><span class="line">	<span class="comment">// 同时计算对应的 key 插入的 cell 位置，和 value 插入的位置。</span></span><br><span class="line">	<span class="keyword">if</span> inserti == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// all current buckets are full, allocate a new one.</span></span><br><span class="line">		newb := h.newoverflow(t, b)</span><br><span class="line">		inserti = &amp;newb.tophash[<span class="number">0</span>]</span><br><span class="line">		insertk = add(unsafe.Pointer(newb), dataOffset)</span><br><span class="line">		val = add(insertk, bucketCnt*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 17. 真正执行存储 key 和 value 以及 tophash 值的动作，</span></span><br><span class="line">	<span class="comment">// 但需要考虑 key 和 value 是否为指针的情况，</span></span><br><span class="line">	<span class="comment">// 当插入完毕后，更新当前 map 的元素的数量 count。</span></span><br><span class="line">	<span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">		kmem := newobject(t.key)</span><br><span class="line">		*(*unsafe.Pointer)(insertk) = kmem</span><br><span class="line">		insertk = kmem</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> t.indirectvalue() &#123;</span><br><span class="line">		vmem := newobject(t.elem)</span><br><span class="line">		*(*unsafe.Pointer)(val) = vmem</span><br><span class="line">	&#125;</span><br><span class="line">	typedmemmove(t.key, insertk, key)</span><br><span class="line">	*inserti = top</span><br><span class="line">	h.count++</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 18. 程序执行到这里，表示当前 key/value 已经插入成功，</span></span><br><span class="line">	<span class="comment">// 但有可能在插入过程序执行了扩容以及创建 overflow bucket 的动作。</span></span><br><span class="line">done:</span><br><span class="line">	<span class="comment">// 19. 再次检测是否存在 go routine 并发写，</span></span><br><span class="line">	<span class="comment">// 然后，重置当前 map 的写状态，</span></span><br><span class="line">	<span class="comment">// 最后，返回当前 key 所关联的 value 存储的地址</span></span><br><span class="line">	<span class="keyword">if</span> h.flags&amp;hashWriting == <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">"concurrent map writes"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	h.flags &amp;^= hashWriting</span><br><span class="line">	<span class="keyword">if</span> t.indirectvalue() &#123;</span><br><span class="line">		val = *((*unsafe.Pointer)(val))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，同 map 元素查询操作类似，mapassign 同样有一系列的函数，其根据 key 具体类型，编译器将其优化为相应的快速函数。</p>
<h2 id="map-扩容函数"><a href="#map-扩容函数" class="headerlink" title="map 扩容函数"></a>map 扩容函数</h2><p>考虑到在 map 元素插入或更新，以及 map 元素的删除操作中都涉及到 map 扩容逻辑（bucket 渐近式迁移过程），因此在阐述 map 元素的删除操作之前，先重点了解 map 的扩容原理。下文从三个方面阐述 map 的扩容原理，首先介绍触发 map 扩容的条件，其次阐述扩容的准备工作（即 hashGrow 函数的逻辑），最后重点阐述扩容的具体逻辑（即 growWork 和 evacuate 的逻辑）。</p>
<h3 id="map-扩容的触发条件"><a href="#map-扩容的触发条件" class="headerlink" title="map 扩容的触发条件"></a>map 扩容的触发条件</h3><p>在 mapassign 函数中，在最外层循环包含了检测当前 map 的扩容触发条件是否成立的代码逻辑。具体如下所示。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;</span><br><span class="line">		hashGrow(t, h)</span><br><span class="line">		<span class="keyword">goto</span> again</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>h.growing()</code>方法简单地根据当前 map 的 oldbuckets 是否为空以判断当前 map 是否处于扩容状态。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hmap)</span> <span class="title">growing</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> h.oldbuckets != <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而<code>overLoadFactor()</code>函数则判断当添加当前元素后，是否触发增量扩容（扩大为原容量的两倍）。所谓增量扩容是由当前 map 包含过多的元素导致的，换言之，bucket 数量过少，因此需要增加 bucket 的数量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">overLoadFactor</span><span class="params">(count <span class="keyword">int</span>, B <span class="keyword">uint8</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> count &gt; bucketCnt &amp;&amp; <span class="keyword">uintptr</span>(count) &gt; loadFactorNum*(bucketShift(B)/loadFactorDen)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后的<code>tooManyOverflowBuckets()</code>函数则判断是否触发了等量扩容。所谓等量扩容是由于当前 map 包含过多的 overflow bucket 导致的，而过多的 oveflow bucket 实际上是相对于 bucket 数量而言的，其准确的描述为：map 中包含的 overflow bucket 的数量和 bucket 的数量基本持平，则说明 overflow bucket 中的 cell 非常稀疏（因为若非常紧凑，则早已触发了增量扩容）。因此，等量扩容的目的是将 overflow bucket 中的元素尽可能迁移到 bucket 中，以提高 bucket 的利用率，也间接提高了元素的查询效率。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等量扩容的判断条件。在此情况下，overflow buckets 的使用通常是稀疏的，否则早就执行扩容操作了（超过 loadFactor）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tooManyOverflowBuckets</span><span class="params">(noverflow <span class="keyword">uint16</span>, B <span class="keyword">uint8</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> B &gt; <span class="number">15</span> &#123;</span><br><span class="line">		B = <span class="number">15</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 当 bucket 数量不大于 1&lt;&lt;15 时，则触发条件为 overflow bucket 的数量是否超过 bucket 的数量；</span></span><br><span class="line">	<span class="comment">// 否则，其触发条件为 overflow bucket 的数量是否超过 1&lt;&lt; 15。</span></span><br><span class="line">	<span class="keyword">return</span> noverflow &gt;= <span class="keyword">uint16</span>(<span class="number">1</span>)&lt;&lt;(B&amp;<span class="number">15</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的解释可能让读者有些疑惑，为何当 bucket 数量大于 1&lt;&lt;15 时，还是判断 overflow bucket 的数量（noverflow）是否大于 1&lt;&lt;15 以确定是否需要执行等量扩容。源码中注释提示我们需要结合<code>incrnoverflow()</code>函数来理解。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hmap)</span> <span class="title">incrnoverflow</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 因为 noverflow 为 uint16 类型，因此需要限制 h.B 的大小。</span></span><br><span class="line">    <span class="comment">// 当 bucket 数量不大于 1&lt;&lt;15 时，则每次都会直接递增 noverflow 的值，</span></span><br><span class="line">    <span class="comment">// 因此，此时 noverflow 的值是一个准确的值。所以，当 noverflow &gt; 1&lt;&lt;15 时，</span></span><br><span class="line">    <span class="comment">// 会触发等量扩容。</span></span><br><span class="line">	<span class="keyword">if</span> h.B &lt; <span class="number">16</span> &#123;</span><br><span class="line">		h.noverflow++</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 当 bucket 数量大于 1&lt;&lt;15 时，每次调用 h.incrnoverflow()，</span></span><br><span class="line">	<span class="comment">// 不一定会增加 noverflow 的大小，实际上它是以 1/(1&lt;&lt;(h.B-15)) 概率递增 h.noverflow，</span></span><br><span class="line">	<span class="comment">// 换言之，结合 tooManyOverflowBuckets() 方法中的判断是否触发等量扩容的条件来看，</span></span><br><span class="line">	<span class="comment">// 当 bucket 数量大于 1&lt;&lt;15 时，只要 noverflow 的值超过 1&lt;&lt;15，则说明需要执行等量扩容。</span></span><br><span class="line">	<span class="comment">// 这个近似的操作是合理的。</span></span><br><span class="line">	mask := <span class="keyword">uint32</span>(<span class="number">1</span>)&lt;&lt;(h.B<span class="number">-15</span>) - <span class="number">1</span></span><br><span class="line">	<span class="comment">// Example: if h.B == 18, then mask == 7,</span></span><br><span class="line">	<span class="comment">// and fastrand &amp; 7 == 0 with probability 1/8.</span></span><br><span class="line">	<span class="keyword">if</span> fastrand()&amp;mask == <span class="number">0</span> &#123;</span><br><span class="line">		h.noverflow++</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="map-扩容的准备工作"><a href="#map-扩容的准备工作" class="headerlink" title="map 扩容的准备工作"></a>map 扩容的准备工作</h3><p><code>hashGrow()</code>函数完成  map 扩容的准备工作。其操作内容大致包括两个方面，首先它会申请新的 bucket 空间，同时更新 oldbucket。其次，更新（转移）迭代器的状态，同时初始化 bucket 的迁移进度。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hashGrow</span><span class="params">(t *maptype, h *hmap)</span></span> &#123;</span><br><span class="line">	<span class="comment">// bigger 为增量扩容的扩大因子，即扩大为原来的两倍</span></span><br><span class="line">	<span class="comment">// 1. 判断是否触发了增量扩容，若触发的是等量扩容，则重置 bigger 为 0，</span></span><br><span class="line">	<span class="comment">// 并标记当前是处于等量扩容状态。</span></span><br><span class="line">	<span class="comment">// 然后，保存当前的 bucket 指针，同时开辟新的 bucket 空间。</span></span><br><span class="line">	<span class="comment">// 需要说明的是，无论是等量扩容还是增量扩容，都需要重新开辟 bucket 数组空间，</span></span><br><span class="line">	<span class="comment">// 只是开辟的大小不同。</span></span><br><span class="line">	bigger := <span class="keyword">uint8</span>(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">if</span> !overLoadFactor(h.count+<span class="number">1</span>, h.B) &#123;</span><br><span class="line">		bigger = <span class="number">0</span></span><br><span class="line">		h.flags |= sameSizeGrow</span><br><span class="line">	&#125;</span><br><span class="line">	oldbuckets := h.buckets</span><br><span class="line">	newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, <span class="literal">nil</span>)</span><br><span class="line">	<span class="comment">// 2. &amp;^ 为按位置 0 操作符。 z := x &amp;^ y, 它将 y 中的 1 bit 清零，否则保持和 x 相同。</span></span><br><span class="line">	<span class="comment">// 简单而言，在 buckets 转移到 oldBuckets 下之后，此操作转移对应的迭代器的标志位。</span></span><br><span class="line">	flags := h.flags &amp;^ (iterator | oldIterator)</span><br><span class="line">	<span class="keyword">if</span> h.flags&amp;iterator != <span class="number">0</span> &#123;</span><br><span class="line">		flags |= oldIterator</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 3. 提交 grow 操作，即更新 map 使其真正处于扩容状态。</span></span><br><span class="line">	<span class="comment">// 同时切换 overflow 和 nextOverflow 指针</span></span><br><span class="line">	h.B += bigger</span><br><span class="line">	h.flags = flags</span><br><span class="line">	h.oldbuckets = oldbuckets</span><br><span class="line">	h.buckets = newbuckets</span><br><span class="line">	h.nevacuate = <span class="number">0</span> <span class="comment">// 初始化扩容进度（ bucket 迁移进度为 0）</span></span><br><span class="line">	h.noverflow = <span class="number">0</span> <span class="comment">// 重置 overflow bucket 数量</span></span><br><span class="line">	<span class="keyword">if</span> h.extra != <span class="literal">nil</span> &amp;&amp; h.extra.overflow != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> h.extra.oldoverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">			throw(<span class="string">"oldoverflow is not nil"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		h.extra.oldoverflow = h.extra.overflow</span><br><span class="line">		h.extra.overflow = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> h.extra == <span class="literal">nil</span> &#123;</span><br><span class="line">			h.extra = <span class="built_in">new</span>(mapextra)</span><br><span class="line">		&#125;</span><br><span class="line">		h.extra.nextOverflow = nextOverflow</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// the actual copying of the hash table data is done incrementally</span></span><br><span class="line">	<span class="comment">// by growWork() and evacuate().</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="map-渐近式扩容原理"><a href="#map-渐近式扩容原理" class="headerlink" title="map 渐近式扩容原理"></a>map 渐近式扩容原理</h3><p>map 元素的插入或修改，以及删除操作都可能执行到 map 的渐近式扩容操作。比如上一小节的 mapassign 函数中存在如下逻辑。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">	growWork(t, h, bucket)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growWork</span><span class="params">(t *maptype, h *hmap, bucket <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1. 再一次确认此次扩容需要迁移的 bucket 索引，然后执行 evacuate 进行 bucket 迁移</span></span><br><span class="line">	evacuate(t, h, bucket&amp;h.oldbucketmask())</span><br><span class="line">	<span class="comment">// 2. 若当前还是处于扩容状态，即当前还剩有 bucket 未迁移完成，</span></span><br><span class="line">	<span class="comment">// 则再迁移一个 bucket</span></span><br><span class="line">	<span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">		evacuate(t, h, h.nevacuate)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>growWork 函数的操作比较简单，它最多执行两个 bucket （包括每个 bucket 后所挂的 overflow bucket）的迁移过程。真正的 bucket 迁移的逻辑位于函数  evacuate 中。同样，在展示其源码注释逻辑时，先概述整个 bucket 迁移过程。</p>
<p>整个 bucket 迁移过程大到处包含四个步骤。首先，获取需要被迁移的 bucket 的地址。其次，若当前 bucket 未被迁移，则依据当前扩容的类型，并根据被迁移的 bucket 在旧的 bucket 数组中的索引，定位其在新的 bucket 数组中插入前半段或者后半段对应的目标 bucket 地址，换言之，后续只需将被迁移的旧的 bucket 中的所有元素逐一插入到新的 bucket 中即可。具体同样是通过两层循环实现，外层循环遍历当前旧的 bucket 链中的每一个 bucket，而内层循环遍历每个 bucket 中的 8 个 cell。具体地，在内层循环遍历过程中，一旦发现当前 cell 的 tophash 为 evacuatedEmpty，则表明其已被迁移。另外，若此次扩容为增量扩容，则还要判断当前 bucket 的元素是迁移到新的 bucket 数组的前半段还是后半段，确定好之后，就可以将原 bucket 中的 key 和 value 存储到对应的目标 bucket 中，然后继续迁移下一个元素。同时，若目标 bucket 没有更多空间容纳被迁移的元素时，则同样在目标 bucket 后挂一个 overflow bucket。第三个步骤执行清除 bucket 操作，即当当前 bucket 已迁移完毕后，且若当前被迁移的 bucket 未被 go routine 使用，则清空旧的 bucket 所存储的 cell 空间。最后，更新 bucket 迁移进度，若所有旧的 bucket 都迁移完成，则清空 map 中包含的旧的 bucket 数组指针和 overflow 指针 。map 渐近式扩容的函数 <a href="https://github.com/golang/go/blob/release-branch.go1.12/src/runtime/map.go#L1136" target="_blank" rel="noopener">evacuate</a> 的源码如下。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被迁移到新的数组中的目标 bucket 结构</span></span><br><span class="line"><span class="keyword">type</span> evacDst <span class="keyword">struct</span> &#123;</span><br><span class="line">	b *bmap          </span><br><span class="line">	i <span class="keyword">int</span>            </span><br><span class="line">	k unsafe.Pointer </span><br><span class="line">	v unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evacuate</span><span class="params">(t *maptype, h *hmap, oldbucket <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// evacuate 迁移 oldbucket 索引处的 bucket</span></span><br><span class="line">	<span class="comment">// 1. 计算需要迁移的 bucket (oldbucket索引) 的地址偏移，同时计算出旧的 bucket 的容量</span></span><br><span class="line">	b := (*bmap)(add(h.oldbuckets, oldbucket*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">	newbit := h.noldbuckets()</span><br><span class="line">	<span class="comment">// 2. 若当前 bucket 未被迁移，则开始执行迁移的逻辑。</span></span><br><span class="line">	<span class="comment">// 具体是判断当前 bucket 的首个 tophash 值是否介于 emptyOne 和 minTopHash 中间，</span></span><br><span class="line">	<span class="comment">// 即处于迁移完毕的状态。</span></span><br><span class="line">	<span class="keyword">if</span> !evacuated(b) &#123;</span><br><span class="line">		<span class="comment">// 3. evacDst 表示迁移的目标 bucket 结构，因此，x 和 y 分别表示迁移到新的 bucket 数组中的前半段还是后半段。</span></span><br><span class="line">		<span class="comment">// x.b 计算出当前被迁移的 bucket b，其对应的在新的 bucket 数组中处于前半段的地址</span></span><br><span class="line">		<span class="comment">// x.k 计算出当前被迁移的 bucket b，其存储的 key 对应的在新的 bucket 数组中处于前半段的 cell 地址</span></span><br><span class="line">		<span class="comment">// x.v 计算出当前被迁移的 bucket b，其存储的 key 关联的 value 对应的在新的 bucket 数组中处于前半段的地址</span></span><br><span class="line">		<span class="comment">// 上述三个计算是关联的，递进式计算求值。</span></span><br><span class="line">		<span class="keyword">var</span> xy [<span class="number">2</span>]evacDst</span><br><span class="line">		x := &amp;xy[<span class="number">0</span>]</span><br><span class="line">		x.b = (*bmap)(add(h.buckets, oldbucket*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">		x.k = add(unsafe.Pointer(x.b), dataOffset)</span><br><span class="line">		x.v = add(x.k, bucketCnt*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">		<span class="comment">// 4. 通过 h.flags 字段判断是否是增量扩容，</span></span><br><span class="line">		<span class="comment">// 若是，则需计算当前被迁移的 bucket b 放置到新的 bucket 数组后半段的具体情况。</span></span><br><span class="line">		<span class="comment">// 类似地，计算 evacDst 包含的三个字段的值。</span></span><br><span class="line">		<span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">			y := &amp;xy[<span class="number">1</span>]</span><br><span class="line">			y.b = (*bmap)(add(h.buckets, (oldbucket+newbit)*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">			y.k = add(unsafe.Pointer(y.b), dataOffset)</span><br><span class="line">			y.v = add(y.k, bucketCnt*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 5. 同样是两层循环，外层循环遍历当前需要被迁移的 bucket b 以及挂在其后的 overflow bucket</span></span><br><span class="line">		<span class="comment">// 内层循环遍历每个 bucket 的 8 个 cell</span></span><br><span class="line">		<span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">			<span class="comment">// 6. 计算当前 bucket 存储 key 和 value 的起始地址偏移</span></span><br><span class="line">			k := add(unsafe.Pointer(b), dataOffset)</span><br><span class="line">			v := add(k, bucketCnt*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">			<span class="comment">// 7. 遍历当前 bucket 的 8 个 cell</span></span><br><span class="line">			<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; bucketCnt; i, k, v = i+<span class="number">1</span>, add(k, <span class="keyword">uintptr</span>(t.keysize)), add(v, <span class="keyword">uintptr</span>(t.valuesize)) &#123;</span><br><span class="line">				<span class="comment">// 8. 获取对应 cell 的 key 的 tophash，</span></span><br><span class="line">				<span class="comment">// 若为 empty，则表示其已被迁移，则将其 tophash 标记为 evacuatedEmpty，继续遍历下一个 cell</span></span><br><span class="line">				<span class="comment">// 同时若当前 key 为指针类型，对当前 key 进行解引用，获取对应的 key 值</span></span><br><span class="line">				top := b.tophash[i]</span><br><span class="line">				<span class="keyword">if</span> isEmpty(top) &#123;</span><br><span class="line">					b.tophash[i] = evacuatedEmpty</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 未迁移的 cell 只可能是 empty 或是正常的 tophash（大于 minTopHash）</span></span><br><span class="line">				<span class="keyword">if</span> top &lt; minTopHash &#123;</span><br><span class="line">					throw(<span class="string">"bad map state"</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				k2 := k</span><br><span class="line">				<span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">					k2 = *((*unsafe.Pointer)(k2))</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 9. useY 表示当前 bucket 被迁移到新的 bucket 的后半段</span></span><br><span class="line">				<span class="comment">// 若当前执行增量扩容，则首先计算 key 的 hash 值。</span></span><br><span class="line">				<span class="keyword">var</span> useY <span class="keyword">uint8</span></span><br><span class="line">				<span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">					hash := t.key.alg.hash(k2, <span class="keyword">uintptr</span>(h.hash0))</span><br><span class="line">					<span class="keyword">if</span> h.flags&amp;iterator != <span class="number">0</span> &amp;&amp; !t.reflexivekey() &amp;&amp; !t.key.alg.equal(k2, k2) &#123;</span><br><span class="line">						<span class="comment">// 9.1 需要注意的一种情况是：当扩容的同时存在 go routine 对 map 进行迭代，</span></span><br><span class="line">						<span class="comment">// 同时，发现相同的 key 值，计算得出不同的 hash 值，这种情况只在 NaN 才出现。</span></span><br><span class="line">						<span class="comment">// 因为，所有的 NaN 值都不同。</span></span><br><span class="line">						<span class="comment">// 对于这种 key 可以随意对其目标进行分配，而且 NaN 的 tophash 也没有意义，</span></span><br><span class="line">						<span class="comment">// 但还是给它计算一个随机的 tophash</span></span><br><span class="line">                        <span class="comment">// 同时，公平地把这些 key(NaN) 均匀分布到前半段和后半段</span></span><br><span class="line">						useY = top &amp; <span class="number">1</span></span><br><span class="line">						top = tophash(hash)</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="comment">// 9.2 通过 hash&amp;newbit 是否为 0，来决定当前 key 被迁移到新的 bucket 数组的前半段还是后半段。</span></span><br><span class="line">						<span class="comment">// newbit 为旧的 map 容量大小。</span></span><br><span class="line">						<span class="comment">// 事实上这是一个 trick，比如对于旧容量为 16 的情况，即 h.B = 4,</span></span><br><span class="line">						<span class="comment">// bucket 的映射算法为 maskBucket &amp; hash，即取决于 1111 &amp;  hash 值，</span></span><br><span class="line">						<span class="comment">// 当容量扩大一倍后，可通过其第 B 位为 0 还是 1 来判断迁移到新的 bucket 数组的前半段还是后半段。</span></span><br><span class="line">						<span class="keyword">if</span> hash&amp;newbit != <span class="number">0</span> &#123;</span><br><span class="line">							useY = <span class="number">1</span></span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> evacuatedX+<span class="number">1</span> != evacuatedY || evacuatedX^<span class="number">1</span> != evacuatedY &#123;</span><br><span class="line">					throw(<span class="string">"bad evacuatedN"</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 10. 设置迁移完成的 bucket cell 的状态为 evacuatedX 或 evacuatedY，</span></span><br><span class="line">				<span class="comment">// 分别表示迁移到新的 bucket 数组中的前半段或者后半段。</span></span><br><span class="line">				b.tophash[i] = evacuatedX + useY <span class="comment">// evacuatedX + 1 == evacuatedY</span></span><br><span class="line">				dst := &amp;xy[useY]                 <span class="comment">// evacuation destination</span></span><br><span class="line">				<span class="comment">// 11. 若当前的 tophash 的位置索引超过了 8，则表明当前的 bucket 已经存储满了，</span></span><br><span class="line">				<span class="comment">// 需要在其后挂上新的 overflow bucket，同时初始化其属性值。</span></span><br><span class="line">				<span class="keyword">if</span> dst.i == bucketCnt &#123;</span><br><span class="line">					dst.b = h.newoverflow(t, dst.b)</span><br><span class="line">					dst.i = <span class="number">0</span></span><br><span class="line">					dst.k = add(unsafe.Pointer(dst.b), dataOffset)</span><br><span class="line">					dst.v = add(dst.k, bucketCnt*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 12. 设置目标 bucket 指定索引处的 tophash 值，</span></span><br><span class="line">				<span class="comment">// 类似地，若 key 或 value 存储指针值，则将原 key/value 复制到新位置。</span></span><br><span class="line">				<span class="comment">// 最后，更新目标迁移 bucket 的属性值，以为后续元素的迁移做准备</span></span><br><span class="line">				dst.b.tophash[dst.i&amp;(bucketCnt<span class="number">-1</span>)] = top </span><br><span class="line">				<span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">					*(*unsafe.Pointer)(dst.k) = k2 <span class="comment">// copy pointer</span></span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					typedmemmove(t.key, dst.k, k) <span class="comment">// copy value</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> t.indirectvalue() &#123;</span><br><span class="line">					*(*unsafe.Pointer)(dst.v) = *(*unsafe.Pointer)(v)</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					typedmemmove(t.elem, dst.v, v)</span><br><span class="line">				&#125;</span><br><span class="line">				dst.i++</span><br><span class="line">				dst.k = add(dst.k, <span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">				dst.v = add(dst.v, <span class="keyword">uintptr</span>(t.valuesize))</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 13. 若没有 go routine 在使用旧的 buckets，则将旧的 buckets 清除掉，减轻 gc 压力</span></span><br><span class="line">        <span class="comment">// 即清除掉此 bucket 所存储的 cell(key 和 value) 的空间</span></span><br><span class="line">		<span class="keyword">if</span> h.flags&amp;oldIterator == <span class="number">0</span> &amp;&amp; t.bucket.kind&amp;kindNoPointers == <span class="number">0</span> &#123;</span><br><span class="line">			b := add(h.oldbuckets, oldbucket*<span class="keyword">uintptr</span>(t.bucketsize))</span><br><span class="line">			ptr := add(b, dataOffset)</span><br><span class="line">			n := <span class="keyword">uintptr</span>(t.bucketsize) - dataOffset</span><br><span class="line">			memclrHasPointers(ptr, n)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 14. 最后，若此次迁移的 bucket 正好是当前进度值，则更新扩容进度</span></span><br><span class="line">	<span class="keyword">if</span> oldbucket == h.nevacuate &#123;</span><br><span class="line">		advanceEvacuationMark(h, t, newbit)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">advanceEvacuationMark</span><span class="params">(h *hmap, t *maptype, newbit <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1. 更新 bucket 迁移进度</span></span><br><span class="line">	h.nevacuate++</span><br><span class="line">	<span class="comment">// 2. 尝试往后最多看 1024 个 bucket，在这些 bucket 中找一个还没有被迁移的 bucket，作为当前迁移进度</span></span><br><span class="line">	stop := h.nevacuate + <span class="number">1024</span></span><br><span class="line">	<span class="keyword">if</span> stop &gt; newbit &#123;</span><br><span class="line">		stop = newbit</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> h.nevacuate != stop &amp;&amp; bucketEvacuated(t, h, h.nevacuate) &#123;</span><br><span class="line">		h.nevacuate++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 3. 若当前 bucket 迁移进度表示已经扩容完成，则清空旧的 bucket 数组指针，</span></span><br><span class="line">	<span class="comment">// 以及 overflow bucket 指针，同时，清除表示当前正在进行扩容的标志位。</span></span><br><span class="line">	<span class="keyword">if</span> h.nevacuate == newbit &#123; <span class="comment">// newbit == # of oldbuckets</span></span><br><span class="line">		h.oldbuckets = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">if</span> h.extra != <span class="literal">nil</span> &#123;</span><br><span class="line">			h.extra.oldoverflow = <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		h.flags &amp;^= sameSizeGrow</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="map-元素删除"><a href="#map-元素删除" class="headerlink" title="map 元素删除"></a>map 元素删除</h2><p>map 元素的删除函数为 <a href="https://github.com/golang/go/blob/release-branch.go1.12/src/runtime/map.go#L691" target="_blank" rel="noopener">mapdelete</a>，若读者熟悉前面的 map 操作，则 map 元素删除操作也是容易理解的，基本过程和 mapassign 类似，同样会检测是否需要涉及协助迁移 bucket 的操作。具体地，先做一些判断工作，然后根据 key 来定位 bucket 和 cell。然后将对应的 key 和 value 清除掉，同时将 bucket 对应索引位置的 tophash 设置为 emptyOne。最后，更新 map 包含的元素数量，恢复未写状态等。主要区别有两点：其一，找到 cell 之后，需要将对应的 key 和 value 给清除，对应代码如下。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">	*(*unsafe.Pointer)(k) = <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> t.key.kind&amp;kindNoPointers == <span class="number">0</span> &#123;</span><br><span class="line">	memclrHasPointers(k, t.key.size)</span><br><span class="line">&#125;</span><br><span class="line">v := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="keyword">uintptr</span>(t.keysize)+i*<span class="keyword">uintptr</span>(t.valuesize))</span><br><span class="line"><span class="keyword">if</span> t.indirectvalue() &#123;</span><br><span class="line">	*(*unsafe.Pointer)(v) = <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> t.elem.kind&amp;kindNoPointers == <span class="number">0</span> &#123;</span><br><span class="line">	memclrHasPointers(v, t.elem.size)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	memclrNoHeapPointers(v, t.elem.size)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其二，考虑到删除一个元素后，当前 bucket 的 cell 可能已全部被清空，甚至当前 bucket （overflow bucket）的前面的 bucket 也为空，则需要依次将这些 bucket 的状态设置为 emptyRest。具体操作逻辑比较简单，这里就不展示相关代码了。最后，同 map 元素的查询、插入或修改类似，map 元素的删除也会根据 key 的具体类型，将其优化成更具体的函数。</p>
<h2 id="map-元素遍历"><a href="#map-元素遍历" class="headerlink" title="map 元素遍历"></a>map 元素遍历</h2><p>map 元素遍历包含两个关键点。即 map 迭代顺序的原理，以及 map 迭代操作和 map 扩容操作的并发执行过程。</p>
<ul>
<li>map 的迭代不保证顺序。这在源码中体现为对于某一次迭代操作，其随机初始化迭代初始的 bucket 索引，同时，随机初始化对应的 bucket 中的 cell 的索引。因此，绝大多数情况下，map 的迭代操作是从中间 bucket 索引位置开始的，往后遍历（地址增长方向），当遍历到 bucket 数组末尾时，则会调转方向，重新到 bucket 数组的起始位置开始遍历，直至遍历到开始生成的随机 bucket 索引的位置，说明 bucket 数组已经遍历完成；</li>
<li>map 的迭代操作可能同扩容操作并发执行。对于增量扩容而言，bucket  还有可能被迁移到新的 bucket 数组中，也有可能还处于旧的 bucket 数组。这给 map 的迭代操作带来了较大的复杂性。具体而言，当 map 当前迭代的 bucket 处于旧的 bucket 数组时（还未被迁移），则迭代器会指向旧的 bucket 数组中对应 bucket 索引，然后，遍历对应 bucket 包含的 cell，同时，只会输出（返回）那些将被迁移到当前 bucket 的元素，这是因为对于增量扩容的情形，旧的 bucket 中的元素有可能被迁移到新的 bucket 数组中的前半段或者后半段。当将位于旧的 bucket 数组中的对应的 bucket （包括挂在其后的 overflow bucket）所有的 cell 遍历完成后，仍旧会返回到原来的（新的）bucket 数组中，然后，更新当前迭代的 bucket 索引，继续往后遍历。</li>
</ul>
<p>map 元素的遍历在源码中对应两个函数，其中 <a href="https://github.com/golang/go/blob/release-branch.go1.12/src/runtime/map.go#L804" target="_blank" rel="noopener">mapiterinit</a> 执行迭代器结构的初始化操作，同时调用 <a href="https://github.com/golang/go/blob/release-branch.go1.12/src/runtime/map.go#L853" target="_blank" rel="noopener">mapnext</a> 以获取当前迭代器指向的元素的 key 和 value，同时更新迭代器的状态，指向下一个元素，持续遍历直至遍历完所有元素。mapiterinit 函数的源码如下，删除了不太相关的逻辑。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapiterinit</span><span class="params">(t *maptype, h *hmap, it *hiter)</span></span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="comment">// 1. 若当前 map 为 nil 或长度为0，则直接返回</span></span><br><span class="line">	<span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	it.t = t</span><br><span class="line">	it.h = h</span><br><span class="line">	<span class="comment">// 2. 将 map 当前的状态复制到迭代器</span></span><br><span class="line">	it.B = h.B</span><br><span class="line">	it.buckets = h.buckets</span><br><span class="line">	<span class="keyword">if</span> t.bucket.kind&amp;kindNoPointers != <span class="number">0</span> &#123;</span><br><span class="line">		h.createOverflow()</span><br><span class="line">		it.overflow = h.extra.overflow</span><br><span class="line">		it.oldoverflow = h.extra.oldoverflow</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 3. 这就是每次迭代同一个 map 将打印不同的元素顺序的一个原因。</span></span><br><span class="line">	<span class="comment">// 其每次推迭代时，会随机从一个 bucket 索引开始，针对此 bucket 还会随机从其中的一个 cell 索引开始</span></span><br><span class="line">	r := <span class="keyword">uintptr</span>(fastrand())</span><br><span class="line">	<span class="keyword">if</span> h.B &gt; <span class="number">31</span>-bucketCntBits &#123;</span><br><span class="line">		r += <span class="keyword">uintptr</span>(fastrand()) &lt;&lt; <span class="number">31</span></span><br><span class="line">	&#125;</span><br><span class="line">	it.startBucket = r &amp; bucketMask(h.B)</span><br><span class="line">	it.offset = <span class="keyword">uint8</span>(r &gt;&gt; h.B &amp; (bucketCnt - <span class="number">1</span>))</span><br><span class="line">	<span class="comment">// 4. 设置当前指向的 bucket 索引（初始时，即为随机抽到的 bucket 索引）</span></span><br><span class="line">	it.bucket = it.startBucket</span><br><span class="line">	<span class="comment">// 5. 设置当前正处于迭代 map 的过程，多个迭代操作可以并发进行</span></span><br><span class="line">	<span class="keyword">if</span> old := h.flags; old&amp;(iterator|oldIterator) != iterator|oldIterator &#123;</span><br><span class="line">		atomic.Or8(&amp;h.flags, iterator|oldIterator)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 6. 获取当前迭代器指向的元素的 key 和 value，同时更新迭代器的状态，指向下一个元素</span></span><br><span class="line">	mapiternext(it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mapiternext 函数源码如下，同样删除了部分不太相关的逻辑。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapiternext</span><span class="params">(it *hiter)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1. 首先获取迭代器的一些状态值，同时禁止 map 的并发迭代和写入</span></span><br><span class="line">	h := it.h</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">"concurrent map iteration and map write"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	t := it.t</span><br><span class="line">	bucket := it.bucket</span><br><span class="line">	b := it.bptr</span><br><span class="line">	i := it.i</span><br><span class="line">	checkBucket := it.checkBucket</span><br><span class="line">	alg := t.key.alg</span><br><span class="line">	<span class="comment">// 2. next 标签表示一个 bucket 的迭代过程，</span></span><br><span class="line">	<span class="comment">// 即当一个 bucket 所有的 cell 遍历完成后，会继续遍历下一个 overflow bucket，</span></span><br><span class="line">	<span class="comment">// 然后返回到此处，再执行元素的整个定位逻辑。</span></span><br><span class="line">next:</span><br><span class="line">	<span class="comment">// 3. 若 b 为 nil，则表示当前正是迭代的开始（还未遍历任何元素）</span></span><br><span class="line">	<span class="keyword">if</span> b == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 3.1 这个条件表明迭代指针返回到了起始迭代的位置，即整个迭代过程已经完成了。</span></span><br><span class="line">		<span class="comment">// it.wrapped 表示已经从头开始遍历了，因为，最开始是从中间的 bucket 开始遍历的。</span></span><br><span class="line">		<span class="comment">// 此时，标记 key 和 value 为 nil，表明迭代结束。</span></span><br><span class="line">		<span class="keyword">if</span> bucket == it.startBucket &amp;&amp; it.wrapped &#123;</span><br><span class="line">			<span class="comment">// end of iteration</span></span><br><span class="line">			it.key = <span class="literal">nil</span></span><br><span class="line">			it.value = <span class="literal">nil</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 3.2 这个条件表明 map 当前正在执行扩容操作。</span></span><br><span class="line">		<span class="comment">// 此时，若当前迭代指针所指向的 bucket 未被迁移完成，则需要到旧的 bucket 执行迭代遍历，</span></span><br><span class="line">		<span class="comment">// 同时，只输出（返回）那些将被迁移到当前（新的） bucket 的那些元素。</span></span><br><span class="line">		<span class="comment">// 具体地，它计算出当前遍历的 bucket 在旧的 bucket 数组中的索引 oldbucket，</span></span><br><span class="line">		<span class="comment">// 然后，计算出对应的旧的 bucket 地址偏移。</span></span><br><span class="line">		<span class="comment">// 接下来，通过当前 bucket 的第一个 tophash 值的状态，以判断当前 bucket 是否已经迁移完成。</span></span><br><span class="line">		<span class="comment">// 若未迁移完成，则设置 checkBucket 为当前正在迭代的旧的 bucket，</span></span><br><span class="line">		<span class="comment">// 否则，表示当前 bucket 已经迁移完毕，则还是在新的 bucket 数组中定位到对应的 bucket 地址，</span></span><br><span class="line">		<span class="comment">// 同时，将 checkBucket 为 noCheck，表示当前迭代的 bucket 不受扩容的影响。</span></span><br><span class="line">		<span class="keyword">if</span> h.growing() &amp;&amp; it.B == h.B &#123;</span><br><span class="line">			oldbucket := bucket &amp; it.h.oldbucketmask()</span><br><span class="line">			b = (*bmap)(add(h.oldbuckets, oldbucket*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">			<span class="keyword">if</span> !evacuated(b) &#123;</span><br><span class="line">				checkBucket = bucket</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				b = (*bmap)(add(it.buckets, bucket*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">				checkBucket = noCheck</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 3.3 否则，表明当前 map 未执行扩容操作，则直接计算对应的 bucket 地址即可，</span></span><br><span class="line">			<span class="comment">// 同样，将 checkBucket 为 noCheck，表示当前迭代的 bucket 不受扩容的影响。</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			b = (*bmap)(add(it.buckets, bucket*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">			checkBucket = noCheck</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 3.4 更新当前迭代的 bucket 索引，若当前迭代的 bucket 索引等于 bucket 的数量减一，</span></span><br><span class="line">		<span class="comment">// 则表示从中间开始遍历 bucket，已经遍历到末尾了，因此重置 bucket 索引，同时设置 wrapped。</span></span><br><span class="line">		<span class="comment">// 即表示下一次迭代时，需要从头开始遍历前一部分的 bucket 元素。</span></span><br><span class="line">		<span class="comment">// 最后，在每次迭代 bucket 的开始，初始化当前迭代的 cell 的数目 i（不是 cell 的索引）。</span></span><br><span class="line">		bucket++</span><br><span class="line">		<span class="keyword">if</span> bucket == bucketShift(it.B) &#123;</span><br><span class="line">			bucket = <span class="number">0</span></span><br><span class="line">			it.wrapped = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		i = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 4. 设置好当前迭代的 bucket 索引后，就开始循环遍历此 bucket 中的 cell</span></span><br><span class="line">	<span class="comment">// 注意此循环中的 i 在每次迭代时会递增，而当迭代一个新的 bucket 后，会清零。</span></span><br><span class="line">	<span class="keyword">for</span> ; i &lt; bucketCnt; i++ &#123;</span><br><span class="line">		<span class="comment">// 4.1 计算当前迭代遍历的 cell 的索引。 &amp; (bucketCnt - 1) 目的是避免溢出。</span></span><br><span class="line">		<span class="comment">// 若当前迭代的 cell 的索引处的 tophash 值为空，或者为 evacuatedEmpty，</span></span><br><span class="line">		<span class="comment">// 表明当前 cell 没有元素，或者当前 cell 被迁移了。</span></span><br><span class="line">		<span class="comment">// 因此，继续遍历下一个 cell。</span></span><br><span class="line">		offi := (i + it.offset) &amp; (bucketCnt - <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span> isEmpty(b.tophash[offi]) || b.tophash[offi] == evacuatedEmpty &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 4.2 通过 cell 的索引，计算出对应的 key 和 value，</span></span><br><span class="line">		<span class="comment">// 同时，若 key 为指针，则解引用。</span></span><br><span class="line">		k := add(unsafe.Pointer(b), dataOffset+<span class="keyword">uintptr</span>(offi)*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">		<span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">			k = *((*unsafe.Pointer)(k))</span><br><span class="line">		&#125;</span><br><span class="line">		v := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="keyword">uintptr</span>(t.keysize)+<span class="keyword">uintptr</span>(offi)*<span class="keyword">uintptr</span>(t.valuesize))</span><br><span class="line">		<span class="comment">// 4.3 此条件表明迭代的 map 正在执行扩容操作，而且是增量扩容。</span></span><br><span class="line">		<span class="comment">// 且此时的 bucket 地址对应的是旧的 bucket 地址。</span></span><br><span class="line">		<span class="keyword">if</span> checkBucket != noCheck &amp;&amp; !h.sameSizeGrow() &#123;</span><br><span class="line">			<span class="comment">// 4.3.1 正常情况下（除了 key 为 NaN）都会走这里。</span></span><br><span class="line">			<span class="comment">// 同时，正如前面所说，只遍历出那些将会迁移到新的 bucket 中的元素。</span></span><br><span class="line">			<span class="keyword">if</span> t.reflexivekey() || alg.equal(k, k) &#123;</span><br><span class="line">				hash := alg.hash(k, <span class="keyword">uintptr</span>(h.hash0))</span><br><span class="line">				<span class="keyword">if</span> hash&amp;bucketMask(it.B) != checkBucket &#123;</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 4.3.2 否则，表明此 key 为 NaN，因此，正如在 evacuate 方法中所阐述的，</span></span><br><span class="line">				<span class="comment">// 对于 NaN 元素，在扩容过程中，以随机（50%）的概率被迁移到新的数组的前半段和后半段。</span></span><br><span class="line">				<span class="comment">// 因此，这里和之前的逻辑相对应，看其 tophash 的最低位是否为 1，</span></span><br><span class="line">				<span class="comment">// 若是，则迁移到后半段，否则迁移到前半段。</span></span><br><span class="line">				<span class="keyword">if</span> checkBucket&gt;&gt;(it.B<span class="number">-1</span>) != <span class="keyword">uintptr</span>(b.tophash[offi]&amp;<span class="number">1</span>) &#123;</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 4.4 进入到此条件表明 key 为正常的未被迁移的元素（包括 NaN）</span></span><br><span class="line">		<span class="comment">// 则直接设置迭代器的 key 和 value 即可。</span></span><br><span class="line">		<span class="keyword">if</span> (b.tophash[offi] != evacuatedX &amp;&amp; b.tophash[offi] != evacuatedY) ||</span><br><span class="line">			!(t.reflexivekey() || alg.equal(k, k)) &#123;</span><br><span class="line">			it.key = k</span><br><span class="line">			<span class="keyword">if</span> t.indirectvalue() &#123;</span><br><span class="line">				v = *((*unsafe.Pointer)(v))</span><br><span class="line">			&#125;</span><br><span class="line">			it.value = v</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 4.5 执行到此处表明对应的元素已经被迁移，更新甚至删除了，</span></span><br><span class="line">			<span class="comment">// 因此调用 mapaccessK 来深度获取对应的 key 和 value</span></span><br><span class="line">			rk, rv := mapaccessK(t, h, k)</span><br><span class="line">			<span class="keyword">if</span> rk == <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">continue</span> <span class="comment">// key has been deleted</span></span><br><span class="line">			&#125;</span><br><span class="line">			it.key = rk</span><br><span class="line">			it.value = rv</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 4.6 更新迭代器当前迭代的 bucket 索引，同时递增当前 bucket 中被遍历的 cell 的数目。</span></span><br><span class="line">		<span class="comment">// 设置 checkBucket 的值，因为下一次迭代过程，可能仍旧遍历的是扩容过程中未被迁移的 bucket。</span></span><br><span class="line">		<span class="comment">// 然后返回。</span></span><br><span class="line">		it.bucket = bucket</span><br><span class="line">		<span class="keyword">if</span> it.bptr != b &#123; <span class="comment">// avoid unnecessary write barrier; see issue 14921</span></span><br><span class="line">			it.bptr = b</span><br><span class="line">		&#125;</span><br><span class="line">		it.i = i + <span class="number">1</span></span><br><span class="line">		it.checkBucket = checkBucket</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 4.7 若执行到这里，表明当前迭代的 bucket 的所有 cell 已经遍历完毕。</span></span><br><span class="line">	<span class="comment">// 因此，需要继续遍历下一个 overflow bucket，</span></span><br><span class="line">	<span class="comment">// 同时，重置 i 为 0，表示当前迭代的 bucket 已遍历的 cell 数目 为 0。</span></span><br><span class="line">	<span class="comment">// 随即跳转到 next 标签处。</span></span><br><span class="line">	b = b.overflow(t)</span><br><span class="line">	i = <span class="number">0</span></span><br><span class="line">	<span class="keyword">goto</span> next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，Go map 的几个典型操作的执行逻辑已经阐述完毕。</p>
<p>简单小结，本文围绕  map 介绍了七个方面的内容，其中重点为『map 基本实现原理』、『map 元素查询』以及『map 扩容函数』。七个方面的内容小结如下。</p>
<ul>
<li>『map 基本实现原理』从 map 的数据结构和扩容原理两个层面概述 map 实现原理，同时，将 Go map 同 Java 的 HashMap 以及 C++ 的 unorderedMap 进行了原理上简单对比，最后介绍了一些关键的数据结构、常量以及 util 函数，这有助于理解后续介绍的 map 的各操作的逻辑。若读者不能读完全文，仅了解此小节的内容也能够了解 map 的大致实现原理；</li>
<li>『map 创建函数』简单介绍了 map 的创建过程，其返回的是 hmap 类型的指针；</li>
<li>『map 元素查询』详细介绍了 map 执行指定元素 key 的查询逻辑，在理解了 bucket、key 以及 value 通过指针地址定位的操作，以及 bucket 和 cell 的映射方法之后，其重点在于遍历两层循环以查找指定的 key 所对应的 value；</li>
<li>『map 元素插入或更新』相较于 map 元素的查询逻辑会更复杂，虽然其也包括两层循环来查找指定的 key 和 value，但考虑到 map 元素插入或更新可能会执行 map 的渐进式扩容操作，因此，在此方法中其会协助迁移至多两个 bucket，一旦执行了迁移操作，则需要重新执行 key 的整个定位过程；</li>
<li>『map 扩容函数』是个较为复杂的过程。因此，将其拆解为 map 扩容的触发条件、map 扩容的准备工作以及 map 渐进式扩容原理这三个部分来阐述。其重点在于渐进式扩容的过程，考虑到对于增量扩容的情况，原 bucket 数组中指定 bucket 元素可能被迁移到新开辟的 bucket 数组的前半段或者后半段；</li>
<li>『map  元素删除』相关逻辑比较简单，同 map 元素插入或更新类似，只不过多了一个清理过程，即将空的 bucket 设置为 emptyRest 状态。</li>
<li>『map 元素遍历』主要包括迭代器初始化以及获取当前迭代器指向元素的 key 和 value，同时更新迭代器的状态以指向下一个元素。其中，获取迭代器指向元素的逻辑较为复杂，因为它也需要考虑迭代操作和扩容操作的并发执行，在这种情形下，对于增量扩容，且当前迭代器指向的 bucket 还未迁移完毕，则需要进入到旧的 bucket 数组中指定 bucket 索引处遍历所有的 cell，并返回那些将会被迁移到对应的新的 bucket 索引的元素。</li>
</ul>
<p>最后，相信对于本文开头提出的那些疑问，读者心中已经有了解答。『参考文献』部分列出文中涉及的资料出处。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]. <a href="https://github.com/golang/go/blob/release-branch.go1.12/src/runtime/map.go" target="_blank" rel="noopener">https://github.com/golang/go/blob/release-branch.go1.12/src/runtime/map.go</a><br>[2]. <a href="https://www.cnblogs.com/qcrao-2018/p/10903807.html#什么是-map" target="_blank" rel="noopener">深度解密Go语言之map</a><br>[3]. <a href="https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics" target="_blank" rel="noopener">How the Go runtime implements maps efficiently (without generics)</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/go/" rel="tag"># go</a>
          
        </div>
      

      
      
        <div class="post-widgets">
        

        

        
          
          <div id="needsharebutton-postbottom">
            <span class="btn">
              <i class="fa fa-share-alt" aria-hidden="true"></i>
            </span>
          </div>
        
        </div>
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/05/23/go-slice-最佳实践/" rel="next" title="go slice 最佳实践">
                <i class="fa fa-chevron-left"></i> go slice 最佳实践
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/06/04/go-函数和方法运行时调用解析/" rel="prev" title="go 函数和方法运行时调用解析">
                go 函数和方法运行时调用解析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div id="gitalk-container"></div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Zeng Qiaoqiao</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">42</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">58</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/qqzeng" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:qtozeng@gmail.com" target="_blank" title="Email">
                      
                        <i class="fa fa-fw fa-envelope"></i>Email</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#map-基本实现原理"><span class="nav-number">1.</span> <span class="nav-text">map 基本实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#map-实现原理概述"><span class="nav-number">1.1.</span> <span class="nav-text">map 实现原理概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map-实现涉及的关键数据结构"><span class="nav-number">1.2.</span> <span class="nav-text">map 实现涉及的关键数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map-实现涉及的关键常量和-util-函数"><span class="nav-number">1.3.</span> <span class="nav-text">map 实现涉及的关键常量和 util 函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#map-创建函数"><span class="nav-number">2.</span> <span class="nav-text">map 创建函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#map-元素查询"><span class="nav-number">3.</span> <span class="nav-text">map 元素查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#map-元素插入或更新"><span class="nav-number">4.</span> <span class="nav-text">map 元素插入或更新</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#map-扩容函数"><span class="nav-number">5.</span> <span class="nav-text">map 扩容函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#map-扩容的触发条件"><span class="nav-number">5.1.</span> <span class="nav-text">map 扩容的触发条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map-扩容的准备工作"><span class="nav-number">5.2.</span> <span class="nav-text">map 扩容的准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map-渐近式扩容原理"><span class="nav-number">5.3.</span> <span class="nav-text">map 渐近式扩容原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#map-元素删除"><span class="nav-number">6.</span> <span class="nav-text">map 元素删除</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#map-元素遍历"><span class="nav-number">7.</span> <span class="nav-text">map 元素遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考文献"><span class="nav-number">8.</span> <span class="nav-text">参考文献</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zeng Qiaoqiao</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">222.4k</span>
  
</div>


<!--

  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>

-->




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
  <script src="/js/src/md5.min.js"></script>
   <script type="text/javascript">
        var gitalk = new Gitalk({
          clientID: '254c17f1918f80ab52dd',
          clientSecret: '34c85cd4d80c0f06e9818833a9ae32a9ba4cc669',
          accessToken: '708b17957b91acd33283ceae79fa7a1ad50c714f', 
          repo: 'qqzeng.github.io',
          owner: 'qqzeng',
          admin: ['qqzeng'],
          id: md5(location.pathname),
          distractionFreeMode: 'true'
        })
        gitalk.render('gitalk-container')
    </script>

  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  
  
  <link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css">

  
  
  <script src="/lib/needsharebutton/needsharebutton.js"></script>

  <script>
    
      pbOptions = {};
      
          pbOptions.iconStyle = "box";
      
          pbOptions.boxForm = "horizontal";
      
          pbOptions.position = "bottomCenter";
      
          pbOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-postbottom', pbOptions);
    
    
  </script>

  

  
  


  

  

  <!-- 代码块复制功能 -->
  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap')
      $(e).after($wrap)
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text()
        }).toArray().join('\n')
        var ta = document.createElement('textarea')
        document.body.appendChild(ta)
        ta.style.position = 'absolute'
        ta.style.top = '0px'
        ta.style.left = '0px'
        ta.value = code
        ta.select()
        ta.focus()
        var result = document.execCommand('copy')
        document.body.removeChild(ta)
        
          if(result)$(this).text('复制成功')
          else $(this).text('复制失败')
        
        $(this).blur()
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn')
        setTimeout(function () {
          $b.text('复制')
        }, 300)
      }).append(e)
    })
  </script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->

</body>
</html>
